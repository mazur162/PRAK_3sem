# P02

В данном практическом задании необходимо было написать библиотеку для работы с графами и затем решить задачу с помощью функций этой библиотеки.

###### БИБЛИОТЕКА С БИНАРНЫМ ДЕРЕВОМ

Я написала библиотку для реализации бинарного дерева (bin_tree_lib.c).
В библиотеке помимо описания самой структуры дерева имеются следующие функции:

tree_t *init_tree(void) - Инициализация дерева
tree_t *create_node(int value, int depth) - Создание узла
void delete_tree(tree_t *node) - Удаление дерева
void insert_node(tree_t **node_ptr, int value, int depth) - Вставка узла
int sum_of_elements_on_levels(tree_t* node, char parity) - Сумма элементов на уровнях определенной четности: parity = 0 для чет, parity = 1 для нечет
int find_max(tree_t* node) - Поиск максимума
int find_min(tree_t* node) - Поиск минимума
char search_value(tree_t* node, int val) - Поиск значения в дереве

С помощью библиотеки я решаю несколько задач:

1) Найти сумму элементов на нечетных уровнях бинарного дерева.
2) Найти сумму элементов на четных уровнях бинарного дерева.
3) Найти максимальный элемент бинарного дерева.
4) Найти минимальный элемент бинарного дерева.
5) Проверить, есть ли в дереве узел с введенным значением.

###### БИБЛИОТЕКА С ВВОДОМ-ВЫВОДОМ

Функции ввода-вывода и текстового представлния графа реализованы в отдельной библиотеке (bin_tree_input_output.c)

void print_tree(tree_t *node, int N) - Вывод дерева
tree_t * input_output(int argc, char** argv) - Взаимодействие с пользователем и вывод ответов на задачи

Если что-то было введено неправильно, то будет выведено сообщение об ошибке и программа завершится с кодом 1.

Вывод дерева происходит по алгоритму "вывод в ширину", то есть печатаются значения узлов, находящихся на одном уровне. Для того, чтобы не "забывать" или вновь не искать значения последующих узлов я размещаю эти узлы в очередь, которая описана в отдельной библиотеке.

###### БИБЛИОТЕКА С ОЧЕРЕДЬЮ

Структуры очереди и узла и различные функции объявлены в библиотеке (queue_lib.c)

Функции:
void queue_init(queue_t* q) - Инициализация очереди
int queue_push(queue_t* q, const void* ptr) - Разщение элемента в очередь
void queue_pop(queue_t* q) - Получение элемента из очереди
const void* queue_head(queue_t* q) - Указатель на голову очереди
int queue_empty_check(queue_t* q) - Проверка на то, пустая ли очередь

###### КОМПИЛЯЦИЯ

Компиляция модулей и сборка происходит с помощью Makefile, который также находится в архиве. При компиляции используются флаги ejudge.

###### ЗАПУСК И АРГУМЕНТЫ КОМАНДНОЙ СТРОКИ

После компиляции все модули программы собираются в программу с названием myprog.
Предусмотрено 3 варианта запуска программы:

1) manual - полностью ручной режим, элементы дерева необходимо будет ввести самостоятельно в стандартный поток ввода
2) random - программа выдает случайные значения в веденный границах
3) test1/test2 - запуск с определенными значениями

Для запуска необходимо написать следующую команду: ./myprog `<mode>`
Например, ./myprog test1

###### ПРИМЕР

Рассмотрим test1:

N = 7
Elements: 10 5 19 17 21 1 6

Binary tree:

```
           10          
      5           19 
 1      6      17      21 
```

`Sum of elements on odd levels: 24
Sum of elements on not odd levels: 55
Max: 21
Min: 1
Enter value, that you want to find: 17
FOUND`

---

P.S. Структуры и функции библиотек описаны в заголовочных модулях, названия которых соответсвуют названию библиотеки. Названия типов структур оканчиваются характерным _t, код сопровожден комментариями.
