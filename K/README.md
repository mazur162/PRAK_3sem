# Все задачи комиссий по практикуму

## 2015 - 2016

### K1-15-16-1

Описан тип звена списка

```c
struct Node { 
	struct Node *next;
 	char *elem; 
};
```

Написать функцию

```c
struct Node *delete_all(struct Node *list, const char *str);
```

удаляющую из списка все звенья, содержащие указатели на строки, равные строке `str`, и освобождающую память, занимаемую этими звеньями и соответствующими строками.
Функция принимает указатель на начальное звено в списке и возвращает указатель на начальное звено после удаления. В списке нет заглавного звена. Поле `elem` в списке и параметр `str` никогда не равны `NULL`.

На проверку сдаётся только функция `delete_all` и необходимые для неё директивы `#include`. Определение структуры `Node` и функция `main` из сдаваемого на проверку файла должны быть удалены или закомментированы.

### K1-15-16-2

Программа должна обработать бинарный файл "`input.dat`", расположенный в текущем каталоге и содержащий 32-битные знаковые целые числа. Переставить в данном бинарном файле числа таким образом, чтобы сначала шли все отрицательные числа, а следом шли все неотрицательные числа. Порядок чисел одного знака неважен.
Для работы с файлом необходимо использовать функции низкоуровневого ввода-вывода. В памяти разрешается хранить не более 10 чисел из файла.
Программа должна завершать своё выполнение с кодом возврата 0.

### K1-15-16-3

В аргументах командной строки программе передаются 3 параметра: `CMD1`, `CMD2` и файл `FILE3` (в указанном порядке). Реализуйте конвейер:
`CMD | CMD2 > FILE3`

Файл `FILE3` должен создаваться с правами на чтение и запись только для текущего пользователя. Основной процесс должен дожидаться завершения запущенных им процессов и только после этого завершаться с кодом возврата 0.

### K1-15-16-4

В аргументах командной строки программе передаются 2 параметра `CMD` и `N`. `CMD` - это имя другой программы для запуска, `N` - положительное целое число. Программа должна запустить на выполнение программу `CMD` в отдельное процессе.

Если программа `CMD` после запуска завершилась за `N` секунд, она должна быть завершена принудительно, и на стадартный поток вывода должна быть выдана строка
`Process #id terminated`,
где `#id` - это `PID` процесса.

Если программа `CMD` завершилась менее, чем за `N` секунд с кодом завершения `code`, на стандартный поток вывода должна быть выведена строка
`Process #id exited with code #code`

Если программа `CMD` завершилась менее, чем за `N` секунд из-за получения какого-нибудь сигнала `sig` на стандартный поток вывода должна быть выдана строка
`Process #id signaled by #sig`

В любом случае процесс-родитель должен завершаться сразу после завершения сына. Процесс-родитель должен завершаться с кодом 0.

### com04-1

В аргументах командной строки программе передаются вещественные числа `x1` и `x2` `(x2 > x1)` и целое число `n` `(n > 0)`. Процесс родитель должен создавать два сыновних проуесса `proc1` и `proc2`. Процессы обмениваются данными по следующей схеме.

Процесс `proc1` выводит на стандартный поток вывода цифру `"1"` и значение `x2`, затем отправляет по неименованному каналу процесс `proc2` число `x2`. 

Процесс `proc2` выводит цифру `"2"`, затем пробел, затем число `cos(x`). После этого процесс `proc1` выводит на стандартный поток вывода цифру `"1"`, затем пробел, затем число `x2 - dx`, где `dx` - это `(x2 - x1) / n`, на третьей итерации - число `x2 - 2*dx` и так далее. 

После вывода числа пересылаются в канал. Последним числом, записываемым в канал процесс `proc1`, должно быть число `x1`.

Родитель должен дождаться завершения работы сыновних процессов и сам завершить работу с кодом завершения 0.

Для синхронизации процессов используйте только неименованные каналы. Вещественные числа вводите с 10 значащими десятичными цифрами. Учтите, что ваша программа будет выполняться с перенаправленным стандартным потоком вывода. В этом случае режим буферизации данных при выводе может отличаться от режима буферизации данным при выводе на терминал.

### com04-2

Дано определение типа звена односвязного списка строк

```c
struct ListNode {
	struct ListNode *next; /* указатель на следующее звено в списке */
	char *elem; /* указатель на C-строку в динамической памяти*/
}
```

Написать функцию

```c
struct ListNode *process_list(struct ListNode *list, const char *str);
```

Если значение элемента списка (поле `elem`) не равно строке `str` без учёта регистра букв, и если значение поля `elem` нескольких подряд идущих элементов списка равны без учёта регистра букв, то от всей серии равных элементов оставляется только один первый элемент, все остальные элементы удаляются. Если значение элемента списка равно `str` без учёта регистра букв, соответсвующий элемент списка переставляется в голову списка.

Например, если параметр `str` равен `"B"`, то список `"B", "A", "A", "C", "B", "A", "A", "D", "B"` должен быть преобразован в `"B", "B", "B", "A", "C", "A", "D"`.

При удалении списка необходимо освобождать память, занимаемую элементов списка, так и хранящейся в нём строкой. Функция принимает указатель на начальное звено в списке и должна возвращать указатель на начальное звено модифицированного списка. В списке нет заглавного звена. Поле `elem` узлов списка и параметр `str` никогда не равны нулевому указателю.

На проверку сдаётся только функция `process` и необходимые для неё директивы `#include`. Определение структуры `ListNode` и функция `main` из сдаваемого на проверку файла должны быть удалены или закомментированы.

### com04-3

Напишите функцию `mant_size` с прототипом

```c
int mant_size(ling long value);
```

Функция должна вычислить размер мантиссы числа, то есть разность между номером самого старшего и нулевого бита в группе младших нулевых бит с номером самого старшего единичного бита числа. Например, размер мантиссы числа `1101000` равен `4`, размер мантиссы числа `100` равен `1`. Размер мантиссы числа `0` равен `0`, а размер мантиссы отрицательного числа равен размеру мантиссы соответсвующего положительного числа.
