# Все задачи комиссий по практикуму

## 2015 - 2016

### K1-15-16-1

Описан тип звена списка

```c
struct Node { 
     struct Node *next;
     char *elem; 
};
```

Написать функцию

```c
struct Node *delete_all(struct Node *list, const char *str);
```

удаляющую из списка все звенья, содержащие указатели на строки, равные строке `str`, и освобождающую память, занимаемую этими звеньями и соответствующими строками.
Функция принимает указатель на начальное звено в списке и возвращает указатель на начальное звено после удаления. В списке нет заглавного звена. Поле `elem` в списке и параметр `str` никогда не равны `NULL`.

На проверку сдаётся только функция `delete_all` и необходимые для неё директивы `#include`. Определение структуры `Node` и функция `main` из сдаваемого на проверку файла должны быть удалены или закомментированы.

### K1-15-16-2

Программа должна обработать бинарный файл "`input.dat`", расположенный в текущем каталоге и содержащий 32-битные знаковые целые числа. Переставить в данном бинарном файле числа таким образом, чтобы сначала шли все отрицательные числа, а следом шли все неотрицательные числа. Порядок чисел одного знака неважен.
Для работы с файлом необходимо использовать функции низкоуровневого ввода-вывода. В памяти разрешается хранить не более 10 чисел из файла.
Программа должна завершать своё выполнение с кодом возврата `0`.

### K1-15-16-3

В аргументах командной строки программе передаются 3 параметра: `CMD1`, `CMD2` и файл `FILE3` (в указанном порядке). Реализуйте конвейер:
`CMD | CMD2 > FILE3`

Файл `FILE3` должен создаваться с правами на чтение и запись только для текущего пользователя. Основной процесс должен дожидаться завершения запущенных им процессов и только после этого завершаться с кодом возврата `0`.

### K1-15-16-4

В аргументах командной строки программе передаются 2 параметра `CMD` и `N`. `CMD` - это имя другой программы для запуска, `N` - положительное целое число. Программа должна запустить на выполнение программу `CMD` в отдельное процессе.

Если программа `CMD` после запуска завершилась за `N` секунд, она должна быть завершена принудительно, и на стадартный поток вывода должна быть выдана строка
`Process #id terminated`,
где `#id` - это `PID` процесса.

Если программа `CMD` завершилась менее, чем за `N` секунд с кодом завершения `code`, на стандартный поток вывода должна быть выведена строка
`Process #id exited with code #code`

Если программа `CMD` завершилась менее, чем за `N` секунд из-за получения какого-нибудь сигнала `sig` на стандартный поток вывода должна быть выдана строка
`Process #id signaled by #sig`

В любом случае процесс-родитель должен завершаться сразу после завершения сына. Процесс-родитель должен завершаться с кодом `0`.

### com04-1

В аргументах командной строки программе передаются вещественные числа `x1` и `x2` `(x2 > x1)` и целое число `n` `(n > 0)`. Процесс родитель должен создавать два сыновних проуесса `proc1` и `proc2`. Процессы обмениваются данными по следующей схеме.

Процесс `proc1` выводит на стандартный поток вывода цифру `"1"` и значение `x2`, затем отправляет по неименованному каналу процесс `proc2` число `x2`.

Процесс `proc2` выводит цифру `"2"`, затем пробел, затем число `cos(x`). После этого процесс `proc1` выводит на стандартный поток вывода цифру `"1"`, затем пробел, затем число `x2 - dx`, где `dx` - это `(x2 - x1) / n`, на третьей итерации - число `x2 - 2*dx` и так далее.

После вывода числа пересылаются в канал. Последним числом, записываемым в канал процесс `proc1`, должно быть число `x1`.

Родитель должен дождаться завершения работы сыновних процессов и сам завершить работу с кодом завершения `0`.

Для синхронизации процессов используйте только неименованные каналы. Вещественные числа вводите с 10 значащими десятичными цифрами. Учтите, что ваша программа будет выполняться с перенаправленным стандартным потоком вывода. В этом случае режим буферизации данных при выводе может отличаться от режима буферизации данным при выводе на терминал.

### com04-2

Дано определение типа звена односвязного списка строк

```c
struct ListNode {
     struct ListNode *next; /* указатель на следующее звено в списке */
     char *elem; /* указатель на C-строку в динамической памяти*/
}
```

Написать функцию

```c
struct ListNode *process_list(struct ListNode *list, const char *str);
```

Если значение элемента списка (поле `elem`) не равно строке `str` без учёта регистра букв, и если значение поля `elem` нескольких подряд идущих элементов списка равны без учёта регистра букв, то от всей серии равных элементов оставляется только один первый элемент, все остальные элементы удаляются. Если значение элемента списка равно `str` без учёта регистра букв, соответсвующий элемент списка переставляется в голову списка.

Например, если параметр `str` равен `"B"`, то список `"B", "A", "A", "C", "B", "A", "A", "D", "B"` должен быть преобразован в `"B", "B", "B", "A", "C", "A", "D"`.

При удалении списка необходимо освобождать память, занимаемую элементов списка, так и хранящейся в нём строкой. Функция принимает указатель на начальное звено в списке и должна возвращать указатель на начальное звено модифицированного списка. В списке нет заглавного звена. Поле `elem` узлов списка и параметр `str` никогда не равны нулевому указателю.

На проверку сдаётся только функция `process` и необходимые для неё директивы `#include`. Определение структуры `ListNode` и функция `main` из сдаваемого на проверку файла должны быть удалены или закомментированы.

### com04-3

Напишите функцию `mant_size` с прототипом

```c
int mant_size(ling long value);
```

Функция должна вычислить размер мантиссы числа, то есть разность между номером самого старшего и нулевого бита в группе младших нулевых бит с номером самого старшего единичного бита числа. Например, размер мантиссы числа `1101000` равен `4`, размер мантиссы числа `100` равен `1`. Размер мантиссы числа `0` равен `0`, а размер мантиссы отрицательного числа равен размеру мантиссы соответсвующего положительного числа.

### com04-4

Программе передаются два аргумента командной строки: имя файла для обработки (`FILE`), затем число элементов для обработки (`N`). Файл для обработки - это бинарный файл, содержащий вещественные числа двойной точности. Размер файла всегда кратен размеру одного числа.

Если файл не содержит чисел или содержит только одно число, он не изменяется.

Если файл содержит более одного числа. `i`-е число в файле после обработки вычисляется по формуле `out[i] = 1.5 * in[i] + 0.5 * out[i - 1]`, где `out` - содержимое файла после обработки, а `in` - содержимое файла до обработки.

Число `N` определяет максимальное количество обрабатываемых чисел, то есть если в файле более `N` чисел, то обрабатываются первые `N` чисел, а остальные не изменяются. `in[0]` учитывается в числе `N`.

Таким образом, при `N`  < 1 входной файл вообще не изменяется.

Для работы с файлом необходимо использовать средства низкоуровневого ввода-вывода. Программа должна завершать своё выполнение с кодом возврата `0`.

Пример входных данных: `1 2 3 4 5 6 7 8 9`

Результат работы при `N` = 4 : `1 3.5 6.25 9.125 `

## 2017

### com02-1

Звено двусвязного списка определено следующим образом:

```c
struct Elem {
    struct Elem *next, *prev;
    int count;
    char *str;
};
```

Напишите функцию `process` с прототипом:

```c
struct Elem *process(struct Elem *head);
```

Если поле `count` некоторого элемента списка больше `1`, то функция `process` должна сделать `count - 1` копий этого элемента списка и разместить новые элементы непосредственно после исходного элемента. Чтобы различить оригинальный и скопированные элементы к строке в скопированных элементах добавляется `-k`, где `k` изменяется от 2 и до `count`. После создания нужного количества копий элемента списка счётчик `count` устанавливается равным 1.

Гарантируется, что для любого элемента списка поле `count >= 1` и поле `str` не равно `NULL`.

Функция должна возвращать указатель на начало списка.

Пример.
Если на вход функции попадается список

`{{1, "a"}, {3, "b"}, {1, "c"}}`

Результатом работы должен быть список

`{{1, "a"}, {1, "b"}, {1, "b-2"}, {1, "b-3"}, {1, "c"}}`

### com02-2

В аргументах командной строки задаются:

`N` - число процессов для создания

`FILE1` - текстовый файл, содержащий последовательность 32-битных беззнаковых целых чисел в десятичной записи

`FILE2` - текстовый файл, содержащий последовательность 32-битных беззнаковых целых чисел в шестнадцатеричной записи. Каждое число начинается с начала строки и содержит ровно 8 знаков. Сразу после числа следует символ `\n`. Таким образом, длина каждой строки всегда равна 9.

Основной процесс должен создать `N` процессов, пронумерованных от `0` до `N - 1`. Главный процесс считывает по одному числу из файла `FILE1`. Остаток от деления считанного числа на `N` определяет номер `i` процесса-сына, который должен считать очередной число из файла `FILE2`, выполнить циклических сдвиг влево на `i` разрядов и выполнить побитовое сложение по модулю 2 с накапливаемым в этом процессе результатом. Процесс-сын должен считать только одно число, затем процесс-родитель определит следующего процесса-сына. Начальное значение при побитовом сложении в каждом процессе равно 0.

После чтения всех чисел из файла `FILE1`, процессы по очереди выводят результат вычислений. Результат должен выводиться как 32-битное беззнаковое целое значение в десятичной записи.

Главный процесс дожидается завершения работы всех порождённых процессов, выводит на стандартный поток вывода значение 0 и завершает свою работу.

При циклическом сдвиге влево на один разряд младшие 31 бит сдвигаются на один разря влево, а старший бит исходного числа переходит в младший бит числа результата.

Для синхронизации процессов использовать неименованные каналы.

### com-17-18-01-1

Напишите функцию `bit_reverse` со следующим прототипом:

```c
STYPE bit_reverse(STYPE value);
```

Где `STYPE` - это некоторый целый знаковый тип. Кроме того, определён и тип `UTYPE` - это некоторый целый беззнаковый тип того же размера, что и `STYPE`. Функция меняет порядок бит в числе на противоположный.

Например, рассмотрим 4-битное целое число `0101`. Поменяв порядок бит на противоположный, получим `1010`. Однако, если то же число рассматривать как 9-битовое, то обратный порядок бит будет равен `10100000`.

Сдаваемый на проверку текст должен содержать только функцию `bit_reverse`. Определения типов `STYPE` и `UTYPE` и функция `main` в нём находиться не должны.

### com-17-18-01-2

Программе передаются 3 аргументы командной строки:

`count` -  32-битное знаковое неотрицательное число

`modulo` - 32-битное знаковое положительное число

`prog` - имя программы для запуска

Программа (главный процесс `P0`) должна создать сына (процесс `P1`), который должен создать своего сына (процесс `P2`), главный процесс должен создать второго сына (процесс `P3`), который должен создать своего сына (процесс `P4`).

Процесс `P1` связаывается с процессом `P2` неименованным каналов в направлении от `P1` к `P2`.

Процесс `P2` связаывается с процессом `P4` неименованным каналов в направлении от `P2` к `P4`.

Процесс `P2` запускает с помощью `exec*p` на выполнение программу `prog`, соответствующим образом перенаправляя её стандартные потоки ввода-вывода.

Процесс `P1` генерирует `count` квадратов положительных целых чисел по модулю (то есть, остаток от деления) `modulo` и записывает их в канал. Например, последовательность первых 10 квадратов по модулю 10 равна `1 4 9 6 5 6 9 4 1 0`.

Процесс `P4` считывает данные, поступившие из своего канала и выводит их на стандартный поток вывода, заменяя символ пробела на символ `'\n'`.

Главный процесс ожитает окончания всей системы процессов, выводит на стандартный поток вывода число 0 и символ `'\n'` и завершает работу с кодом `0`.

### com-18-18-01-3

Программе в аргументах командной строки передаются имена файлов для обработки. Файлы могут содержать произвольные данные. Главный процесс должен создать по процессу на каждый обрабатываемый файл. Каждый процесс должен найти байт, который встречается чаще всего. Если таких байтов несколько, то выбирается меньший байт. Для каждого файла в аргументаз командной строки процесс родитель должен вывести на стандартный поток вывода значение наиболее часто встречающегося байта и число его повторений. Если файл пуст, то выводится два нуля. Значения должны выводиться в том же порядке, в котором заданы имена файлов в командной строке.

Затем главный процесс получает от каждого процесса число повторений символа, который оказался наиболее частым в следующем по порядку файле. То есть, первый процесс сообщает родителю частоту повторений в первом файле того символа, который оказался наиболее частым по втором файле. Последний процесс берет наиболее частый символ первого файла. Если следующий по порядке файл оказался пустым, то процесс передает родителю значение 0. Главный процесс выводит на стандартный поток вывода полученные от сыновей числа в порядке следования файлов в командной строке.

Главный процесс дожидается окончания выполнения всех процессов и завершает работу с кодом `0`. Для синхронизации и передачи файлов используйся семафоры и разделяемую память. Все объекты синхронизации должны быть уничтожены.

## 2018

### com02-1

Элемент двухсвязного списка описывается структурой `ListItem`:

```c
struct ListItem {
    struct ListItem *prev, *next;
    unsigned char *str;
}
```

```c
void process (struct ListItem *head, const unsigned char *prefix);
```

Напишите функцию `process`, которая принимает указатель на голову списка и строку для поиска. Функция просматривает элементы списка последовательно от начала к концу. Если у некоторого элемента  списка строка `str` начинается с префикса `prefix`, сразу после которого следует число `N`, записанное в десятичной системе без знаков `+` или `-`, имеющее значение от 1 до 255 (включительно), из списка должны быть удалены `N` элементов, непосредственно следующих за текущим обрабатываемым элементом, либо все оставшиеся элементы списка, если их меньше `N`. После этого функция переходит к просмотру элемента следующего за удалённым. Если строка `str` не удовлетворяет требованиям, описанным выше, то функция переходит к просмотру следующего элемента. Память, занимаемая удаленными элементами, должна быть корректно освобождена.

Например, если задана строка префикса `A`, а некоторый элемент списка хранит строку `A10`, то десять следующих после этого элемента элементов списка должны быть удалены.

Если элемент списка содержит строку `a2b`, то она считается не удовлетворяющей требованиям.

Программа, сдаваемая на процерку, должна содержать определение структуры `ListItem` и функцию `process`. Параметр `prefix` и поле `str` никогда не равны `NULL`.

### com02-2

Программе в аргументах командной строки передаются два имени программы `PROG1` и `PROG2` для запуска.

Главный процесс (процесс 0) создаёт 3 сыновей (процессы 1, 2 и 3). Процессы 1 и 3 создают своих сыновей (процессы 4 и 5 соответсвенно). Процесс 4 связывается неименованным каналом с процессом 2 (от процесса 4 к процессу 2), и процесс 2 связывается неименованным каналом с процессом 5 (от 2 к 5). В процессе 4 на выполнение запускается программа `PROG1`, в процесссе 5 - программа `PROG2`. Программы запускаются с помощью `exec*`.

Процессу 2 от процесса 4 поступает поток 32-битных знаковых чисел в текстовом виде. Числа разделяются пробельными символами. Процесс 2 должен передать процессу 5 только четные целые числа в текстовом виде, разделяя их символом перевода строки.

Главный процесс должен дождать завершения работы всей системы процессов, после чего завершиться с кодом `0`.

### com02-3

Программа должна вывести на стандартный поток вывода свой `PID` и переключиться в режим ожидания поступления сигнала. Каждое поступление сигнала `SIGUSR1` увеличивает значение счётчика на 5. Каждое поступление сигнала `SIGUSR2` уменьшает значение счётчика на 4. Начальное значение счётчика - 32-битового целого числа - равно 0. При поступлении любого из этих сигналов на стандартный поток вывода выводится номер сигнала (значение константы `SIG*`) и значение счётчика после изменения.

Если значение счётчика стало отрицательным, программа завершает работу с кодом завершения `0` после вывода значений. Стандартный ввод и стандартный вывод программы будут перенаправлены. С другой стороны каналов находится другой процесс, поторый начнет свою работу, как только получит `pid` процесса.

Например, если программе отправляются сигналы `SIGUSR1`, `SIGUSR2`, `SIGUSR2`, то программа должна вывести

```
10 5
12 1
12 -3
```

### km01-1

**UART** (Universal Asynchronous Receiver-Transmitter) - это протокол, позволяющий передавать данные по последовательной линии в одной направлении от отправителя к получателю. Когда данные не передаются, на линии установлено напряжение логической единицы, что считается приёмным устройством как единичный бит. Чтобы начать передачу отправитель передает один нулевой бит (так называемый старт-бит), за которым идут 8 бит данных в порядке от младшего бита к старшему, за которыми идёт бит паритета, равный 1, если в переданных 8 битахданных чётное число единиц, и равный 0, еслив них нечётное число единиц. Передачу завершает стоп-бит, всегда равный 1, который снова переводит линию в состояние ожидания новых данных. Таким образом, октеты данных передаются пакетами из 11 бит.

На стандартный поток ввода вашей программы подаётся состояние входной линии (символ `'0'` обозначает логический ноль, '`1'` - логическую единицу). Кроме того, для удобства записи, символы могут разделяться произвольным количеством пробельных (в смысле функции `isspace`) символов. На стандартный поток вывода выведите декодированные из входного потока октеты. Ваш ответ должен совпадать с правильным побитово. Не выводите никаких посторонних символов. Поток данных имеет правильную структуру фреймов, но бит паритета может не совпадать. Если у принятого октета не совпадает бит паритета, выводите символ `'?'` (знак вопроса).

### km01-2

Программе в аргументах командной строки передаётся начальная скорость (32-битное целое знаковое число). Ваша программа должна промоделировать работу цифрового спидометра.

Цифровой спидометр должен обрабатывать прерывания от таймера, которые будут моделироваться с помощью сигнала `ALRM`. Сигналы `USR1` и `USR2` поступают от акселерометра, `USR1` означает, что скорость увеличилась на одну единицу, а `USR2` означает, что что скорость уменьшилась на одну единицу. По сигналу `TERM` программа должна вывести на стандартный поток вывода пройденное расстояние (на момент последнего обработанного `ALRM`) и завершить работу.

Все единицы измерения (время между прерываниями от таймера, скорость, ускорение) согласованы друг с другом, то есть никаких масштабных коэффициентов не требуется.

Стандартный ввод и стандартный вывод программы будут перенаправлены в каналы. Не забывайте сбрасывать буфер вывода. С другой стороны каналов находится другой процесс, который начнёт свою работу как только получит `pid` процесса. Предполагайте, что от вывода `pid` до прихода первого `ALRM` приходит одна единица времени.

Указание: используйте отдельную функцию-обработчик для каждого сигнала.

### km01-3

В данной задаче вам предлагается промоделировать память с расслоением по банкам.

В аргументах командной строки задаются имена бинарных файлов, хранящие содержимое банков памяти. Главная программа запускает по одному процессу на каждый банк памяти и обменивается данными с ними с помощью разделяемой памяти и семафоров.

Главная программа считывает со стандартного потока ввода адреса ячеек памяти, каждая ячейка памяти имеет размер 8 бит. Главная программа определяет номер банка, в котором находится эта ячейка, отправляет запрос в соответсвующий процесс (банк памяти), дожидается ответа и выводит содержимое соответсвующей ячейки памяти на стандартный поток вывода как целое число от 0 до 255.

Можете предполагать, что все файлы с содержимым банков памяти имеют одинаковый размер. Адреса ячеек в памяти представляются беззнаковыми 32-битными целыми числами. Если ячейки с указанным адресом не существует, на стандартный поток вывода должно быть напечатано число `-1`.

При завершении программы все объекты, использованные для обмена информацией между процессами, должны быть удалены.

## 2019

### km01-1

В аргументах командной строки задаются имя входного бинарного файла (`FILE1`), имя выходного бинарного файла (`FILE2`) и положительное 32-битное знаковое число (`MOD`). Файл `FILE1` содержит множество последовательных целых чисел, представленное в виде битового вектора. Бит 0 (младший бит первого байта) в файле соответсвует числу 1, бит 7 (старший бит первого байта ) в файле соответсветсвует числу 8 и т.д. Установленный бит означает, что соответсвующее число присутсвует во множестве. Для каждого числа `x`, присутсвующего во множестве, хранящегося в `FILE1`, в бинарный файл `FILE2` запишите 32-битное знаковое целое число `&sum;<sub>i=1</sub><sup>x</sup> i^2` `(mod MOD)`, то есть остаток от деления на `MOD` суммы квадратов всех чисел от 1 до `х` включительно. Числа должны быть записаны в порядке возрастания значения `х`. Для работы с файлами использовать интерфейс системных вызовов.

Например, если входной бинарный файл содержит байт `0x93`, и значение `MOD` равно `1000`, то в выходной бинарный файл должны быть записаны числа `1, 2, 55, 204`.

### km01-2

Отец (процесс `P0`) порождает двух сыновей (`P1`, `P2`). Процесс `P1` порождает своего сына (`P3`), то есть внука процесса `P0`. Процессы связываются неименованными каналами `P3 -> P2`, `P2 -> P3`, `P1 -> P3`. Обмен данными в каналах ведется парами 64-битных знаковых целых чисел. Изначально процесс `P0` записывает процессу `P3` два числа `1`. После этого начинает работать передача данных по кругу (`P3 -> P2 -> P1 -> P3 -> ...`). Каждый процесс считывает из входного канала пару чисел (обозначим `A` и `B`), выводят свой порядковый номер (`1`, `2`, `3`) и два считанных числа из стандартного потока ввода, записывает в выходной канал числа `B`, `A + B`. Передача данных заканчивается, когда считанное число `B` превосходит значение заданное в командной строке. В этом случае ничего выводить не нужно. Для взаимодействия процессов использовать только неименованные каналы и `wait`. Процесс `P0` долден завершиться последним с кодом завершения `0`.

Например, если в аргументе командной строки указано `10`, то на стандартный поток вывода должно быть напечатано:

```
2 1 1
2 1 2
1 2 3
3 2 5
3 5 8
```
