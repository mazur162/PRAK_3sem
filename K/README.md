# ссоВсе задачи комиссий по практикуму

## 2015 - 2016

### K1-15-16-1

Описан тип звена списка

```c
struct Node { 
     struct Node *next;
     char *elem; 
};
```

Написать функцию

```c
struct Node *delete_all(struct Node *list, const char *str);
```

удаляющую из списка все звенья, содержащие указатели на строки, равные строке `str`, и освобождающую память, занимаемую этими звеньями и соответствующими строками.
Функция принимает указатель на начальное звено в списке и возвращает указатель на начальное звено после удаления. В списке нет заглавного звена. Поле `elem` в списке и параметр `str` никогда не равны `NULL`.

На проверку сдаётся только функция `delete_all` и необходимые для неё директивы `#include`. Определение структуры `Node` и функция `main` из сдаваемого на проверку файла должны быть удалены или закомментированы.

### K1-15-16-2

Программа должна обработать бинарный файл "`input.dat`", расположенный в текущем каталоге и содержащий 32-битные знаковые целые числа. Переставить в данном бинарном файле числа таким образом, чтобы сначала шли все отрицательные числа, а следом шли все неотрицательные числа. Порядок чисел одного знака неважен.
Для работы с файлом необходимо использовать функции низкоуровневого ввода-вывода. В памяти разрешается хранить не более 10 чисел из файла.
Программа должна завершать своё выполнение с кодом возврата `0`.

### K1-15-16-3

В аргументах командной строки программе передаются 3 параметра: `CMD1`, `CMD2` и файл `FILE3` (в указанном порядке). Реализуйте конвейер:
`CMD | CMD2 > FILE3`

Файл `FILE3` должен создаваться с правами на чтение и запись только для текущего пользователя. Основной процесс должен дожидаться завершения запущенных им процессов и только после этого завершаться с кодом возврата `0`.

### K1-15-16-4

В аргументах командной строки программе передаются 2 параметра `CMD` и `N`. `CMD` - это имя другой программы для запуска, `N` - положительное целое число. Программа должна запустить на выполнение программу `CMD` в отдельное процессе.

Если программа `CMD` после запуска завершилась за `N` секунд, она должна быть завершена принудительно, и на стадартный поток вывода должна быть выдана строка
`Process #id terminated`,
где `#id` - это `PID` процесса.

Если программа `CMD` завершилась менее, чем за `N` секунд с кодом завершения `code`, на стандартный поток вывода должна быть выведена строка
`Process #id exited with code #code`

Если программа `CMD` завершилась менее, чем за `N` секунд из-за получения какого-нибудь сигнала `sig` на стандартный поток вывода должна быть выдана строка
`Process #id signaled by #sig`

В любом случае процесс-родитель должен завершаться сразу после завершения сына. Процесс-родитель должен завершаться с кодом `0`.

### com04-1

В аргументах командной строки программе передаются вещественные числа `x1` и `x2` `(x2 > x1)` и целое число `n` `(n > 0)`. Процесс родитель должен создавать два сыновних проуесса `proc1` и `proc2`. Процессы обмениваются данными по следующей схеме.

Процесс `proc1` выводит на стандартный поток вывода цифру `"1"` и значение `x2`, затем отправляет по неименованному каналу процесс `proc2` число `x2`.

Процесс `proc2` выводит цифру `"2"`, затем пробел, затем число `cos(x`). После этого процесс `proc1` выводит на стандартный поток вывода цифру `"1"`, затем пробел, затем число `x2 - dx`, где `dx` - это `(x2 - x1) / n`, на третьей итерации - число `x2 - 2*dx` и так далее.

После вывода числа пересылаются в канал. Последним числом, записываемым в канал процесс `proc1`, должно быть число `x1`.

Родитель должен дождаться завершения работы сыновних процессов и сам завершить работу с кодом завершения `0`.

Для синхронизации процессов используйте только неименованные каналы. Вещественные числа вводите с 10 значащими десятичными цифрами. Учтите, что ваша программа будет выполняться с перенаправленным стандартным потоком вывода. В этом случае режим буферизации данных при выводе может отличаться от режима буферизации данным при выводе на терминал.

### com04-2

Дано определение типа звена односвязного списка строк

```c
struct ListNode {
     struct ListNode *next; /* указатель на следующее звено в списке */
     char *elem; /* указатель на C-строку в динамической памяти*/
}
```

Написать функцию

```c
struct ListNode *process_list(struct ListNode *list, const char *str);
```

Если значение элемента списка (поле `elem`) не равно строке `str` без учёта регистра букв, и если значение поля `elem` нескольких подряд идущих элементов списка равны без учёта регистра букв, то от всей серии равных элементов оставляется только один первый элемент, все остальные элементы удаляются. Если значение элемента списка равно `str` без учёта регистра букв, соответсвующий элемент списка переставляется в голову списка.

Например, если параметр `str` равен `"B"`, то список `"B", "A", "A", "C", "B", "A", "A", "D", "B"` должен быть преобразован в `"B", "B", "B", "A", "C", "A", "D"`.

При удалении списка необходимо освобождать память, занимаемую элементов списка, так и хранящейся в нём строкой. Функция принимает указатель на начальное звено в списке и должна возвращать указатель на начальное звено модифицированного списка. В списке нет заглавного звена. Поле `elem` узлов списка и параметр `str` никогда не равны нулевому указателю.

На проверку сдаётся только функция `process` и необходимые для неё директивы `#include`. Определение структуры `ListNode` и функция `main` из сдаваемого на проверку файла должны быть удалены или закомментированы.

### com04-3

Напишите функцию `mant_size` с прототипом

```c
int mant_size(ling long value);
```

Функция должна вычислить размер мантиссы числа, то есть разность между номером самого старшего и нулевого бита в группе младших нулевых бит с номером самого старшего единичного бита числа. Например, размер мантиссы числа `1101000` равен `4`, размер мантиссы числа `100` равен `1`. Размер мантиссы числа `0` равен `0`, а размер мантиссы отрицательного числа равен размеру мантиссы соответсвующего положительного числа.

### com04-4

Программе передаются два аргумента командной строки: имя файла для обработки (`FILE`), затем число элементов для обработки (`N`). Файл для обработки - это бинарный файл, содержащий вещественные числа двойной точности. Размер файла всегда кратен размеру одного числа.

Если файл не содержит чисел или содержит только одно число, он не изменяется.

Если файл содержит более одного числа. `i`-е число в файле после обработки вычисляется по формуле `out[i] = 1.5 * in[i] + 0.5 * out[i - 1]`, где `out` - содержимое файла после обработки, а `in` - содержимое файла до обработки.

Число `N` определяет максимальное количество обрабатываемых чисел, то есть если в файле более `N` чисел, то обрабатываются первые `N` чисел, а остальные не изменяются. `in[0]` учитывается в числе `N`.

Таким образом, при `N`  < 1 входной файл вообще не изменяется.

Для работы с файлом необходимо использовать средства низкоуровневого ввода-вывода. Программа должна завершать своё выполнение с кодом возврата `0`.

Пример входных данных: `1 2 3 4 5 6 7 8 9`

Результат работы при `N` = 4 : `1 3.5 6.25 9.125 `

## 2017

### com02-1

Звено двусвязного списка определено следующим образом:

```c
struct Elem {
    struct Elem *next, *prev;
    int count;
    char *str;
};
```

Напишите функцию `process` с прототипом:

```c
struct Elem *process(struct Elem *head);
```

Если поле `count` некоторого элемента списка больше `1`, то функция `process` должна сделать `count - 1` копий этого элемента списка и разместить новые элементы непосредственно после исходного элемента. Чтобы различить оригинальный и скопированные элементы к строке в скопированных элементах добавляется `-k`, где `k` изменяется от 2 и до `count`. После создания нужного количества копий элемента списка счётчик `count` устанавливается равным 1.

Гарантируется, что для любого элемента списка поле `count >= 1` и поле `str` не равно `NULL`.

Функция должна возвращать указатель на начало списка.

Пример.
Если на вход функции попадается список

`{{1, "a"}, {3, "b"}, {1, "c"}}`

Результатом работы должен быть список

`{{1, "a"}, {1, "b"}, {1, "b-2"}, {1, "b-3"}, {1, "c"}}`

### com02-2

В аргументах командной строки задаются:

`N` - число процессов для создания

`FILE1` - текстовый файл, содержащий последовательность 32-битных беззнаковых целых чисел в десятичной записи

`FILE2` - текстовый файл, содержащий последовательность 32-битных беззнаковых целых чисел в шестнадцатеричной записи. Каждое число начинается с начала строки и содержит ровно 8 знаков. Сразу после числа следует символ `\n`. Таким образом, длина каждой строки всегда равна 9.

Основной процесс должен создать `N` процессов, пронумерованных от `0` до `N - 1`. Главный процесс считывает по одному числу из файла `FILE1`. Остаток от деления считанного числа на `N` определяет номер `i` процесса-сына, который должен считать очередной число из файла `FILE2`, выполнить циклических сдвиг влево на `i` разрядов и выполнить побитовое сложение по модулю 2 с накапливаемым в этом процессе результатом. Процесс-сын должен считать только одно число, затем процесс-родитель определит следующего процесса-сына. Начальное значение при побитовом сложении в каждом процессе равно 0.

После чтения всех чисел из файла `FILE1`, процессы по очереди выводят результат вычислений. Результат должен выводиться как 32-битное беззнаковое целое значение в десятичной записи.

Главный процесс дожидается завершения работы всех порождённых процессов, выводит на стандартный поток вывода значение 0 и завершает свою работу.

При циклическом сдвиге влево на один разряд младшие 31 бит сдвигаются на один разря влево, а старший бит исходного числа переходит в младший бит числа результата.

Для синхронизации процессов использовать неименованные каналы.

### com-17-18-01-1

Напишите функцию `bit_reverse` со следующим прототипом:

```c
STYPE bit_reverse(STYPE value);
```

Где `STYPE` - это некоторый целый знаковый тип. Кроме того, определён и тип `UTYPE` - это некоторый целый беззнаковый тип того же размера, что и `STYPE`. Функция меняет порядок бит в числе на противоположный.

Например, рассмотрим 4-битное целое число `0101`. Поменяв порядок бит на противоположный, получим `1010`. Однако, если то же число рассматривать как 9-битовое, то обратный порядок бит будет равен `10100000`.

Сдаваемый на проверку текст должен содержать только функцию `bit_reverse`. Определения типов `STYPE` и `UTYPE` и функция `main` в нём находиться не должны.

### com-17-18-01-2

Программе передаются 3 аргументы командной строки:

`count` -  32-битное знаковое неотрицательное число

`modulo` - 32-битное знаковое положительное число

`prog` - имя программы для запуска

Программа (главный процесс `P0`) должна создать сына (процесс `P1`), который должен создать своего сына (процесс `P2`), главный процесс должен создать второго сына (процесс `P3`), который должен создать своего сына (процесс `P4`).

Процесс `P1` связаывается с процессом `P2` неименованным каналов в направлении от `P1` к `P2`.

Процесс `P2` связаывается с процессом `P4` неименованным каналов в направлении от `P2` к `P4`.

Процесс `P2` запускает с помощью `exec*p` на выполнение программу `prog`, соответствующим образом перенаправляя её стандартные потоки ввода-вывода.

Процесс `P1` генерирует `count` квадратов положительных целых чисел по модулю (то есть, остаток от деления) `modulo` и записывает их в канал. Например, последовательность первых 10 квадратов по модулю 10 равна `1 4 9 6 5 6 9 4 1 0`.

Процесс `P4` считывает данные, поступившие из своего канала и выводит их на стандартный поток вывода, заменяя символ пробела на символ `'\n'`.

Главный процесс ожитает окончания всей системы процессов, выводит на стандартный поток вывода число 0 и символ `'\n'` и завершает работу с кодом `0`.

### com-18-18-01-3

Программе в аргументах командной строки передаются имена файлов для обработки. Файлы могут содержать произвольные данные. Главный процесс должен создать по процессу на каждый обрабатываемый файл. Каждый процесс должен найти байт, который встречается чаще всего. Если таких байтов несколько, то выбирается меньший байт. Для каждого файла в аргументаз командной строки процесс родитель должен вывести на стандартный поток вывода значение наиболее часто встречающегося байта и число его повторений. Если файл пуст, то выводится два нуля. Значения должны выводиться в том же порядке, в котором заданы имена файлов в командной строке.

Затем главный процесс получает от каждого процесса число повторений символа, который оказался наиболее частым в следующем по порядку файле. То есть, первый процесс сообщает родителю частоту повторений в первом файле того символа, который оказался наиболее частым по втором файле. Последний процесс берет наиболее частый символ первого файла. Если следующий по порядке файл оказался пустым, то процесс передает родителю значение 0. Главный процесс выводит на стандартный поток вывода полученные от сыновей числа в порядке следования файлов в командной строке.

Главный процесс дожидается окончания выполнения всех процессов и завершает работу с кодом `0`. Для синхронизации и передачи файлов используйся семафоры и разделяемую память. Все объекты синхронизации должны быть уничтожены.

## 2018

### com02-1

Элемент двухсвязного списка описывается структурой `ListItem`:

```c
struct ListItem {
    struct ListItem *prev, *next;
    unsigned char *str;
}
```

```c
void process (struct ListItem *head, const unsigned char *prefix);
```

Напишите функцию `process`, которая принимает указатель на голову списка и строку для поиска. Функция просматривает элементы списка последовательно от начала к концу. Если у некоторого элемента  списка строка `str` начинается с префикса `prefix`, сразу после которого следует число `N`, записанное в десятичной системе без знаков `+` или `-`, имеющее значение от 1 до 255 (включительно), из списка должны быть удалены `N` элементов, непосредственно следующих за текущим обрабатываемым элементом, либо все оставшиеся элементы списка, если их меньше `N`. После этого функция переходит к просмотру элемента следующего за удалённым. Если строка `str` не удовлетворяет требованиям, описанным выше, то функция переходит к просмотру следующего элемента. Память, занимаемая удаленными элементами, должна быть корректно освобождена.

Например, если задана строка префикса `A`, а некоторый элемент списка хранит строку `A10`, то десять следующих после этого элемента элементов списка должны быть удалены.

Если элемент списка содержит строку `a2b`, то она считается не удовлетворяющей требованиям.

Программа, сдаваемая на процерку, должна содержать определение структуры `ListItem` и функцию `process`. Параметр `prefix` и поле `str` никогда не равны `NULL`.

### com02-2

Программе в аргументах командной строки передаются два имени программы `PROG1` и `PROG2` для запуска.

Главный процесс (процесс 0) создаёт 3 сыновей (процессы 1, 2 и 3). Процессы 1 и 3 создают своих сыновей (процессы 4 и 5 соответсвенно). Процесс 4 связывается неименованным каналом с процессом 2 (от процесса 4 к процессу 2), и процесс 2 связывается неименованным каналом с процессом 5 (от 2 к 5). В процессе 4 на выполнение запускается программа `PROG1`, в процесссе 5 - программа `PROG2`. Программы запускаются с помощью `exec*`.

Процессу 2 от процесса 4 поступает поток 32-битных знаковых чисел в текстовом виде. Числа разделяются пробельными символами. Процесс 2 должен передать процессу 5 только четные целые числа в текстовом виде, разделяя их символом перевода строки.

Главный процесс должен дождать завершения работы всей системы процессов, после чего завершиться с кодом `0`.

### com02-3

Программа должна вывести на стандартный поток вывода свой `PID` и переключиться в режим ожидания поступления сигнала. Каждое поступление сигнала `SIGUSR1` увеличивает значение счётчика на 5. Каждое поступление сигнала `SIGUSR2` уменьшает значение счётчика на 4. Начальное значение счётчика - 32-битового целого числа - равно 0. При поступлении любого из этих сигналов на стандартный поток вывода выводится номер сигнала (значение константы `SIG*`) и значение счётчика после изменения.

Если значение счётчика стало отрицательным, программа завершает работу с кодом завершения `0` после вывода значений. Стандартный ввод и стандартный вывод программы будут перенаправлены. С другой стороны каналов находится другой процесс, поторый начнет свою работу, как только получит `pid` процесса.

Например, если программе отправляются сигналы `SIGUSR1`, `SIGUSR2`, `SIGUSR2`, то программа должна вывести

```
10 5
12 1
12 -3
```

### km01-1

**UART** (Universal Asynchronous Receiver-Transmitter) - это протокол, позволяющий передавать данные по последовательной линии в одной направлении от отправителя к получателю. Когда данные не передаются, на линии установлено напряжение логической единицы, что считается приёмным устройством как единичный бит. Чтобы начать передачу отправитель передает один нулевой бит (так называемый старт-бит), за которым идут 8 бит данных в порядке от младшего бита к старшему, за которыми идёт бит паритета, равный 1, если в переданных 8 битахданных чётное число единиц, и равный 0, еслив них нечётное число единиц. Передачу завершает стоп-бит, всегда равный 1, который снова переводит линию в состояние ожидания новых данных. Таким образом, октеты данных передаются пакетами из 11 бит.

На стандартный поток ввода вашей программы подаётся состояние входной линии (символ `'0'` обозначает логический ноль, '`1'` - логическую единицу). Кроме того, для удобства записи, символы могут разделяться произвольным количеством пробельных (в смысле функции `isspace`) символов. На стандартный поток вывода выведите декодированные из входного потока октеты. Ваш ответ должен совпадать с правильным побитово. Не выводите никаких посторонних символов. Поток данных имеет правильную структуру фреймов, но бит паритета может не совпадать. Если у принятого октета не совпадает бит паритета, выводите символ `'?'` (знак вопроса).

### km01-2

Программе в аргументах командной строки передаётся начальная скорость (32-битное целое знаковое число). Ваша программа должна промоделировать работу цифрового спидометра.

Цифровой спидометр должен обрабатывать прерывания от таймера, которые будут моделироваться с помощью сигнала `ALRM`. Сигналы `USR1` и `USR2` поступают от акселерометра, `USR1` означает, что скорость увеличилась на одну единицу, а `USR2` означает, что что скорость уменьшилась на одну единицу. По сигналу `TERM` программа должна вывести на стандартный поток вывода пройденное расстояние (на момент последнего обработанного `ALRM`) и завершить работу.

Все единицы измерения (время между прерываниями от таймера, скорость, ускорение) согласованы друг с другом, то есть никаких масштабных коэффициентов не требуется.

Стандартный ввод и стандартный вывод программы будут перенаправлены в каналы. Не забывайте сбрасывать буфер вывода. С другой стороны каналов находится другой процесс, который начнёт свою работу как только получит `pid` процесса. Предполагайте, что от вывода `pid` до прихода первого `ALRM` приходит одна единица времени.

Указание: используйте отдельную функцию-обработчик для каждого сигнала.

### km01-3

В данной задаче вам предлагается промоделировать память с расслоением по банкам.

В аргументах командной строки задаются имена бинарных файлов, хранящие содержимое банков памяти. Главная программа запускает по одному процессу на каждый банк памяти и обменивается данными с ними с помощью разделяемой памяти и семафоров.

Главная программа считывает со стандартного потока ввода адреса ячеек памяти, каждая ячейка памяти имеет размер 8 бит. Главная программа определяет номер банка, в котором находится эта ячейка, отправляет запрос в соответсвующий процесс (банк памяти), дожидается ответа и выводит содержимое соответсвующей ячейки памяти на стандартный поток вывода как целое число от 0 до 255.

Можете предполагать, что все файлы с содержимым банков памяти имеют одинаковый размер. Адреса ячеек в памяти представляются беззнаковыми 32-битными целыми числами. Если ячейки с указанным адресом не существует, на стандартный поток вывода должно быть напечатано число `-1`.

При завершении программы все объекты, использованные для обмена информацией между процессами, должны быть удалены.

## 2019

### km01-1

В аргументах командной строки задаются имя входного бинарного файла (`FILE1`), имя выходного бинарного файла (`FILE2`) и положительное 32-битное знаковое число (`MOD`). Файл `FILE1` содержит множество последовательных целых чисел, представленное в виде битового вектора. Бит 0 (младший бит первого байта) в файле соответсвует числу 1, бит 7 (старший бит первого байта ) в файле соответсветсвует числу 8 и т.д. Установленный бит означает, что соответсвующее число присутсвует во множестве. Для каждого числа `x`, присутсвующего во множестве, хранящегося в `FILE1`, в бинарный файл `FILE2` запишите 32-битное знаковое целое число

<img src="https://latex.codecogs.com/svg.image?(\sum_{i=1}^{x}&space;i^2)&space;\;&space;mod&space;\;&space;MOD" title="(\sum_{i=1}^{x} i^2) \; mod \; MOD" />

, то есть остаток от деления на `MOD `суммы квадратов всех чисел от 1 до `х `включительно. Числа должны быть записаны в порядке возрастания значения `х`. Для работы с файлами использовать интерфейс системных вызовов.

Например, если входной бинарный файл содержит байт `0x93`, и значение `MOD` равно `1000`, то в выходной бинарный файл должны быть записаны числа `1, 2, 55, 204`.

### km01-2

Отец (процесс `P0`) порождает двух сыновей (`P1`, `P2`). Процесс `P1` порождает своего сына (`P3`), то есть внука процесса `P0`. Процессы связываются неименованными каналами `P3 -> P2`, `P2 -> P3`, `P1 -> P3`. Обмен данными в каналах ведется парами 64-битных знаковых целых чисел. Изначально процесс `P0` записывает процессу `P3` два числа `1`. После этого начинает работать передача данных по кругу (`P3 -> P2 -> P1 -> P3 -> ...`). Каждый процесс считывает из входного канала пару чисел (обозначим `A` и `B`), выводят свой порядковый номер (`1`, `2`, `3`) и два считанных числа из стандартного потока ввода, записывает в выходной канал числа `B`, `A + B`. Передача данных заканчивается, когда считанное число `B` превосходит значение заданное в командной строке. В этом случае ничего выводить не нужно. Для взаимодействия процессов использовать только неименованные каналы и `wait`. Процесс `P0` долден завершиться последним с кодом завершения `0`.

Например, если в аргументе командной строки указано `10`, то на стандартный поток вывода должно быть напечатано:

```
2 1 1
2 1 2
1 2 3
3 2 5
3 5 8
```

### km01-3

Программа должна создать три процесса. Первый созданный процесс должен обрабатывать только `IPv4`-адреса класса `А`, второй процесс - только `IPv4`-адреса класса `B`, третий процесс - только `IPv4` адреса класса `C`. Каждый из этих процессов извлекает из адреса номер сети и печатает класс сети (A, B или C) и номер сети на стандартный поток вывода в шестнадцатеричном виде. Процесс-родитель считывает со стандартного потока ввода `IP`-адреса,  записанные в десятично-точечной нотации, и передает их на обработку соответсвующему процессу-сыну. Для передачи данных должна использоваться разделяемая память и семафоры. Когда отец достигает конца стандартного потока ввода, сначала должны завершиться процессы-сыновья, затем процесс-отец. Созданные объекты `IPC` должны быть уничтожены.

| `Пример входных данных` | `Результат работы` |
| -------------------------------------------- | ----------------------------------- |
| `4.57.256.36`                              | `A 4`                             |
| `130.44.124.158`                           | `B 22c`                           |
| `200.51.236.160`                           | `C 633ee`                         |

## 2020

### km02-1

Структура элемента списка определена следующим образом:

```c
struct ListItem {
    struct ListItem *next;
    char *str;
};
```

Напишите функцию со следующим прототипом:

```c
struct ListItem *list_dup(const struct ListItem *list);
```

Функция должна вернуть новый список строк, который содержит строки исходного списка, которые состоят только из строчных латинских букв. В выходном списке строки должны следовать в обратном порядке к тому, в котором строки находятся в исходном списке.

Например, если на вход функции подан список `{"a", "1", "b", "2", "C"}`, на выходе должен быть получен список `{"b", "a"}`.

Сдаваемый на проверку код должен содержать определение структуры `ListItem` и тело функции `list_dup`.

### km02-2

Программе предаётся два аргумента командной строки: имя бинарного файла `FILE` и положительное целое число `N`. Бинарный файл содержит 64-битные целые числа, но может быть пустым. В этом файле переставить числа, которые находятся на позициях `0`, `N`, `2N`, `3N`, ... и так далее до конца файла, в обратном порядке.

Например, при `N == 2` в содержимом файла `{1, 2, 3, 4, 5}` в результате должен получиться файл `{5, 2, 3, 4, 1}`.

### km03-1

На стандартный поток ввода задаются два числа: `a` - 64-битное знаковое целое число в десятичном виде и `b` (`1 < b < 1000`) основание системы счисления - целое число в десятичном виде.

На стандартный поток вывода напечатайте сумму цифр числа `a`, записанного в системе счисления по основанию `b`. Сумму цифр выведите в десятичной системе счисления. Число `a` может быть отрицательным.

### km03-2

Дана функция `proc`:

```c
int proc(void) {
    int pid = fork();
    if (!pid) {
        write(1, "1\n", 2);  
    }
    return pid;
}
```

Запишите **одно выражение** на языке C, в результате выполнения которой на стандартный поток вывода строка 1 была бы выведена 7 раз. В качестве программы сдайте `main`, содержащий только это выражение. В выражении можно использовать только операции языка Си и вызывать функцию `proc()` не более 4 раз.

### km03-3

На стандартном потоке ввода подаётся последовательность символов, которая заканчивается с признаком конца ввода. Словом назовём последовательность строчный латинских букв ('a', ..., 'z'), идущих в тексте подряд, и максимально возможной длины.

То есть, текст `"abcd"` содержит слово `"abcd"`, а не, например, два слова `"a"` и `"bcd"`. На стандартный поток вывода напечатайте длину самого длинного слова в тексте, не содержащего букву `'q'`. Если такого слова нет, выведите `0`.

### km03-4

В аргументах командной строки передаются числа в восьмеричной системе счисления в диапазоне от 1 до 64 (включительно), разделенные символом `','` (запятая). Рассматривайте эти числа как элементы множества в котором каждое число представляется одним битом, представляя множество в виде 64-битного беззнакового числа и на стандартный поток вывода выведите это число в шестнадцатеричном виде.

### km03-5

В аргументах командной строки задаётся начальная точка `x0` - вещественное число, количество шагов `n` (целое число от 1 до 100000) и шаг `dx` - вещественное число.

Программа должна создать два процесса сына, каждый из которых должен создать одного своего процесса-сына (внука основного процесса). Внук от первого сына отправляет внуку от второго сына значения `sin(x)` для всех точек `x0`, `x0 + dx`, ..., `x0 + n * dx` (всего n + 1 число), а внук от второго сына отправляет первому внуку значения `cos(x)` для всех этих точек. Внук от первого сына вычисляет сумму квадратов полученных чисел, а внук от второго сына - сумму модулей. Каждый из внуков выводит свой номер (1 или 2) и вычисленное число на стандартный поток вывода. Результат вычислений выводите не менее чем с 10 знаками мантиссы.

Отец дожидается завершения работы всех созданных процессов и выводит на стандартный поток вывода два нуля.

## 2021

### km01-1

На стандартном потоке ввода подаются 64-битные беззнаковые числа в шестнадцетеричной записи. На стандартный поток вывода напечатайте 64 числа в десятичной записи, каждое из который равно количеству чисел во входных данных у которых на соответсвующей позиции бит установлен. Первое число в выводе - это количество чисел во входных данных, у которых установлен бит 0 (младший бит), а последнее число в выводе - это количество чисел во входных данных, у которых установлен бит 63 (старший бит).

### km01-2

В аргументе командной строки задается имя бинарного регулярного файла. Бинарный файл содержит 128-битные беззнаковые числа, записанные в порядке Big-Endian (то есть старший байт числа в памяти хранится по меньшему адресу). Отсортируйте числа в порядке возрастания и запишите результат в этот же файл. Размер файла кратен 16 байтам. В файле может находиться не более 2097152 чисел. Глобальные (`static`) переменные использовать запрещено. Памяти достаточно для чтения всего файла в память.

### km01-3

В аргументах командной строки задается 64-битное беззнаковое число `M`, имя программы для запуска `PROG`. Ваша программа должна запустить `PROG`, передав ей на стандартный поток ввода последовательности чисел `0, 1, 4, 9, 16, ... (M - 1)^2` (то есть последовательность квадратов чисел от `0` до `M - 1` в десятичном виде, числа разделяются пробельными символами). Программа должна считать последовательность 64-битных беззнаковых чисел, которые программа `PROG` выводит на стандартный поток вывода, и на стандартный поток вывода напечатать их сумму. Для взаимодействия вашей программы и программы `PROG` используйте неименованные каналы. Программу `PROG` запускайте с помощью `execlp`. Процесс-родитель должен завершиться после всех созданных им процессов с кодом завершения `0`.

### km01-1

**Обработка списка**

Дано определение типа звена двусвязного списка строк:

```
struct Node
{
    struct Node *prev, *next;
    char *elem;
};
```

И определение типа списка

```
struct List
{
    struct Node *first, *last;
};
```

Напишите функцию process, обрабатывающую список за один проход от первого до последнего элемента по нему следующим образом:

```
void process(struct List *pl, const char *str);
```

Звенья, у которых строка elem равна строке str удаляются, а звенья, у которых строка elem лексикографически больше строки str переставляются в конец списка. Прочие звенья не изменяются.

При удалении звена необходимо освобождать память, занимаемую звеном и строкой. В списке нет заглавного звена, и он не закольцован. Поле `elem`, параметры `pl` и `str` никогда не равны `NULL`.

На проверку сдается только функция process и необходимые для нее директивы `#include`.

### km01-2

**Виртуальная память**

Рассмотрим модельный 16-битный процессор с 16-битным виртуальным и физическим адресным пространством, адресуемым побайтно, в котором реализована одноуровневая виртуальная страничная адресация с размером страницы 512 байт. Процессор хранит целые числа в формате Little-Endian.

Первым аргументом командной строки передается бинарный файл размером 64KiB - содержимое физической памяти. Вторым аргументом командной строки передается физический адрес начала таблицы страниц в шестнадцатеричном виде.

Таблица страниц размещается в физической памяти, начиная с указанного адреса. Каждая запись таблицы страниц имеет размер 16 бит, в которой старшие биты хранят номер физической страницы, а младшие биты равны 0.

На стандартном потоке ввода задаются выровненные виртуальные адреса 16-битных ячеек памяти в шестнадцатеричной записи. На стандартный поток вывода напечатайте значения, хранящиеся в ячейках. Значения выводите в беззнаковом десятичном виде.

### km01-3

**Условный запуск программ**

Программе в аргументах командной строки передаются три команды для выполнения. Программа должна запустить на выполнение процессы, чтобы они выполнялись в конфигурации, соответствующей команде shell:

```
{ cmd1 || cmd2 } && cmd3
```

Родительский процесс должен дождаться завершения всех созданных им процессов и сам завершить выполнение с кодом возврата `0` или `1` в зависимости от успешности выполнения процессов.

Команды `cmd1`, `cmd2`, `cmd3` можно запускать на выполнение с помощью `execlp`.

Запись `a || b` означает то же самое, что `!a?b:true`. Запись `a && b` означает то же самое, что `a?b:false`. Скобки `{` и `}` используются для группировки.

Для шелла процесс считается завершившимся успешно, если процесс завершился с помощью системного вызова exit (макрос `WIFEXITED` возвращает истинное значение), и код завершения процесса (макрос `WEXITSTATUS`) равен `0`. В других случаях процесс считается завершившимся неуспешно.

Соответственно, ваша программа должна завершиться с кодом `0` в случае успешного выполнения заданной группы процессов и с кодом `1` в случае неуспешного их выполнения.

Организуйте вашу программу таким образом, чтобы избежать дублирование кода. В частности, запуск процесса и проверка статуса его завершения может быть вынесена в функцию.

 **Примечания по тестированию вашей программы:** . Тестирование завершается с вердиктом `'Synchronization error'`, если процесс-отец (то есть ваша программа, запускаемая на тестирование) заканчивает работу раньше какого-либо из своих потомков.

### km01-4

**Конвейер**

Программе в аргументах командной строки передаются три команды для выполнения, затем два имени файла (всего 5 аргументов командной строки). Программа должна запустить на выполнение процессы, чтобы они выполнялись в конфигурации, соответствующей команде `shell`:

```
( cmd1 < file1 && cmd2 ) | cmd3 >> file2
```

Родительский процесс должен дождаться завершения всех созданных им процессов и сам завершить выполнение.

Считайте, что команды `cmd1`, `cmd2`, `cmd3` можно запускать на выполнение с помощью execlp.

Запись `CMD1 && CMD2` означает, что процесс `CMD2` должен быть запущен только после успешного завершения процесса `CMD1`.

Запись ( `CMD` ) используется для группировки, при этом вся командная строка `CMD` выполняется в отдельном процессе, порожденном основным процессом.

### km01-5

**Сигналы**

Программе на стандартном потоке ввода задаются два целых числа `low` и `high`. Программа должна вывести на стандартный поток вывода свой `PID`, после вывода программа должна обрабатывать получение сигналов `SIGINT` и `SIGTERM`.

Программа должна вычислять простые числа в интервале `[low,high)`. Если программа получила сигнал `SIGINT`, программа должна вывести на стандартный поток вывода последнее на текущей момент найденное простое число. При получении `SIGINT` в четвертый раз, программа должна закончить работу с кодом завершения `0`. Таким образом, может быть выведено не более трех простых чисел.

При получении сигнала `SIGTERM` программа должна завершиться с кодом `0`.

Если программа закончила вычисления, программа должна вывести на стандартный поток вывода число `-1` и завершиться с кодом `0`.

Если на момент прихода сигнала ни одно простое число найдено не было, выводите `0`.

Учтите, что стандартный поток вывода программы будет перенаправлен в `pipe`.

# Другие задачи

## Задачи с зачёта

### 1

Вам дан тип узла двунаправленного закольцованного списка, который хранит Си-строку. Каждый элемент списка содержит адрес свой отдельно обрасти памяти под Си-строку.

```c
struct list_item {
    char *str;
    struct list_item *next, *prev;  
}
```

Напишите функцию

```c
void process (struct list_item **list, const char *s);
```

Она получает на вход указатель на начало двунаправленного закольцованного списка `list` и Си-строку `s`. Функция находит элементы списка, чья строка содержит строку `s` в качестве подстроки, и полностью дублирует этот элемент столько раз, какова длина этой строки. Остальные элементы надо переставить в конец списка с сохранением порядка. Функция должна один раз пройти по списку и не использовать функцию освобождения памяти.

При компиляции флагами из `ejudge` не должно быть функции `main` и объявления типа `struct_item`, т.к. они будут подставлены в `ejudge` при проверке. Для тестирования программы вы можете написать свою функцию `main` в отдельном модуле или воспользоваться условной компиляцией. Все необходимые `#include` должны присутствовать в вашем исходнике.

Пример: если функция получит список: `["a", "xabc", "ab"]` и строку `"abc"`, то список должен стать `["xabc", "xabc", "xabc", "xabc", "xabc", "a", "ab"]`

***Решение*:**

```c
void
process(struct list_item **list, const char *s) {
    struct list_item *ptr = *list;
    struct list_item *last = ptr->prev;
    do {
        struct list_item *nextptr = ptr->next;
        if (strstr(ptr->str, s)) {
            for (int i = 0; i < strlen(ptr->str); i++) {
                struct list_item *new = malloc(sizeof(struct list_item));
                new->str = malloc(strlen(ptr->str) + 1);
                strcpy(new->str, ptr->str);
  
                new->next = ptr->next;
                new->prev = ptr;
                ptr->next = new;
                new->next->prev = new;
            }
            if (ptr == last) {
                last = nextptr->prev;
            }
        } else {
            if (ptr == (*list)) {
                (*list) = (*list)->next;
            } else {
                if (ptr == last) {
                    last = last->prev;
                }
                ptr->prev->next = ptr->next;
                ptr->next->prev = ptr->prev;
                ptr->next = (*list);
                ptr->prev = (*list)->prev;
                (*list)->prev->next = ptr;
                (*list)->prev = ptr;
            }
        }
        ptr = nextptr;

    } while (ptr != last->next);
}
```

### 2

Программа получает на стандартный ввод последовательность строк, каждая строка - это последовательность команд, разделенных точкой с запятой. За последней строкой может не идти перенос строки. Нужно выполнить последовательно все эти команды. Внутри команды точка с запятой не встречается. Команда состоит из последовательности слов - имени программы и её аргументов. "Пустых" команд не может быть (т.е. в строке не может быть в конце и в начале точки с запятой и двух точек с запятой подряд). Программу запускать с использованием переменной `PATH`. Код завершения программы равен коду завершения последней запущенной команды, если она завершилась системным вызовом `_exit`, а иначе `128 + номер сигнала`. Если функция `exec` завершилась ошибкой, процесс завершается с кодом `127`. В случае других ошибок - код завершения `1`. Использовать `bash` напрямую или косвенно запрещается. Все аргументы разделены не менее чем одним пробельным символом. Длина строки ограничена лишь размерами памяти.

Пример ввода:

```
echo 1 ; echo 2
echo 3 4a
```

Ответ:

```
1
2
3 4a
```

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <ctype.h>
#include <unistd.h>

char ***arg = NULL;
int argc = 0;

void
delete(void)
{
    for (int i = 0; i < argc; i++) {
        int j = 0;
        while (arg[i][j] != NULL) {
            free(arg[i][j]);
            j++;
        }
        free(arg[i]);
    }
    free(arg);
}

int
main(void)
{
    int c;
    while ((c = getchar())!= EOF) {
        argc++;
        arg = realloc(arg, argc * sizeof(char **));
        arg[argc - 1] = NULL;
        while (c != EOF && isspace(c)) {
            c = getchar();
        }
        int size = 0, num_arg = 0;
        while (c != EOF && c != ';' && c != '\n') {
            if (num_arg == size) {
                if (size == 0) {
                    size = 1;
                } else {
                    size = size * 2;
                }
                arg[argc - 1] = realloc(arg[argc - 1], size * sizeof (char *));
            }
            arg[argc - 1][num_arg] = NULL;
            int size_word = 0, num_sym_in_word = 0;
            while (c != EOF && !isspace(c) && c != ';') {
                if (num_sym_in_word == size_word) {
                    if (size_word == 0) {
                        size_word = 1;
                    } else {
                        size_word = size_word * 2;
                    }
                    arg[argc - 1][num_arg] = realloc(arg[argc - 1][num_arg], size_word * sizeof(char));
                }
                arg[argc - 1][num_arg][num_sym_in_word] = c;
                num_sym_in_word++;
                c = getchar();
            }
            if (num_sym_in_word == size_word) {
                if (size_word == 0) {
                    size_word = 1;
                } else {
                    size_word = size_word * 2;
                }
                arg[argc - 1][num_arg] = realloc(arg[argc - 1][num_arg], size_word * sizeof(char));
            }
            arg[argc - 1][num_arg][num_sym_in_word] = '\0';
            num_arg++;
            while (c != EOF && isspace(c) && c != '\n') {
                c = getchar();
            }
        }
        if (num_arg == size) {
            if (size == 0) {
                    size = 1;
               } else {
                    size = size * 2;
               }
            arg[argc - 1] = realloc(arg[argc - 1], size * sizeof(char *));
        }
        arg[argc - 1][num_arg] = NULL;
    }
    atexit(delete); // указанная функция будет вызвана при exit
    int status;
    pid_t pid;
    for (int i = 0; i < argc; i++) {
        if ((pid = fork()) == 0) {
            execvp(arg[i][0], arg[i]);
            exit(127);
        } else if (pid == -1) {
            exit(1);
        }
        wait(&status);
    }
    if (WIFEXITED(status)) {
        exit(WIFEXITED(status));
    }
    if (WIFSIGNALED(status)) {
        exit(128 + WTERMSIG(status));
    }
}
```

### 3

Аргументы командной строки вашей программы такие: `p1 arg11 arg12 ... arg1N -- p2 arg22 ... arg2M`. Отец создаёт дочерний процесс и соединяется с ним ровно одним каналом. Отец читает последовательность неотрицательных целых чисел со стандартного ввода. Если он читает `0`, то отправляет сыну сигнал (выберите сами, какой), а если больше `0`, то спит указанное количество микросекунд (функция `usleep`). Сын на каждый третий приход сигнала выполняет команду `p1 arg11 arg12 ... arg1N | p2 arg21 arg22 ... arg2M`, используя `PATH`. Первый пришедший сигнал имеет номер `1`, т.е. первый раз сын должен запустить команду, получив сигнал в третий раз. Команды не должны пересекаться по времени. То есть их надо выполнять последовательно нужное количество раз. Активное ожидание недопустимо. Считать, что последовательность чисел не содержит двух нулей подряд и не оканчивается нулём. Отец завершает сына отправкой сигнала `SIGTERM`, сын должен выполнить все требуемые команды и завершиться.

***Решение:***

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/wait.h>
#include <unistd.h>

int flag_execute = 0, flag_end = 0;

void
signal_handler(int sig)
{
    if (sig == SIGUSR1) {
        static int counter = 0;
        counter++;
        if (counter == 3) {
            flag_execute++;
            counter = 0;
        }
    }
    if (sig == SIGTERM) {
        flag_end = 1;
    }
}

int
main(int argc, char **argv)
{
    int p2;
    for (p2 = 1; p2 < argc; p2++) {
        if (strcmp(argv[p2], "--") == 0) {
            break;
        }
    }
    argv[p2] = NULL;
    p2++;
    int fd[2];
    if (pipe(fd) < 0) {
        return 1;
    }
    signal(SIGUSR1, signal_handler);
    signal(SIGTERM, signal_handler);
    pid_t pid;
    if ((pid = fork()) == 0) {
        while (1) {
            while (!flag_execute && !flag_end) {
                usleep(100);
            }
            if (flag_end && !flag_execute) {
                break;
            }
            if (fork() == 0) {
                dup2(fd[1], 1);
                close(fd[0]);
                close(fd[1]);
                execvp(argv[1], argv + 1);
                exit(127);
            }
            if (fork() == 0) {
                dup2(fd[0], 0);
                close(fd[0]);
                close(fd[1]);
                execvp(argv[p2], argv + p2);
                exit(127);
            }
            close(fd[0]);
            close(fd[1]);
            wait(NULL);
            wait(NULL);
            flag_execute--;
        }
        exit(0);
    }
    signal(SIGUSR1, SIG_DFL);
    signal(SIGTERM, SIG_DFL);
    int num;
    while (scanf("%d", &num) == 1) {
        if (num == 0) {
            kill(pid, SIGUSR1);
        } else {
            usleep(num);
        }
    }
    kill(pid, SIGTERM);
    wait(NULL);
}
```

### 4

Отец получает на стандартный ввод целые неотрицательные числа `N` и `K`. Отец создаёт временный файл и записывает туда число `K`. Затем он запускает параллельно `N` дочерних процессов. Дочерние процессы по очереди по кругу дописывают в конец файла число, на единицу меньшее, чем последнее число в файле. Как только они дошли до `0`, дочерние процессы завершаются. Отец дожидается завершения дочерних процессов, распечатывает последовательно содержимое файла на стандартный вывод и удаляет файл. Глобальными переменными пользоваться нельзя. Синхронизацию процессов осуществить при помощи `IPC`. Число `K` детям иным образом, кроме как в файле, не передавать.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <ctype.h>

int
main (void) {
    int i;
    unsigned int N, K;
    scanf("%u %u", &N, &K);
    char filename[10] = "tmpXXXXXX";
    int tmp_fd = mkstemp(filename);
    write(tmp_fd, &K, sizeof(K));

    union semun {
        int     val;            /* value for SETVAL */
        struct  semid_ds *buf;  /* buffer for IPC_STAT & IPC_SET */
        u_short *array;         /* array for GETALL & SETALL */
     };

    int semid = semget(IPC_PRIVATE, N, IPC_CREAT | 0666);
    u_short *arr = malloc(N*sizeof(u_short));
    arr[0] = 1;
    for (i = 1; i < N; i++) {
        arr[i] = 0;
    }
    semctl(semid, 0, SETALL, (union semun) {.array = arr});
    free(arr);

    for (i = 0; i < N; i++) {
        if (fork() == 0) {
            while (1) {
                unsigned int num;
                semop(semid, &(struct sembuf) {i, -1, 1}, 1);
                lseek(tmp_fd, -sizeof(unsigned int), SEEK_END);
                read(tmp_fd, &num, sizeof(num));
                if (num == 0) {
                    semop(semid, &(struct sembuf) {(i + 1) % N, +1, 0 }, 1);
                    return 0;
                }
                num--;
                write(tmp_fd, &num, sizeof(num));
                semop(semid, &(struct sembuf) {(i + 1) % N, +1, 0 }, 1);
                if (num == 0) {
                    return 0;
                }
            }
        }
    }
    while (wait(NULL) > 0) {;}

    lseek(tmp_fd, 0, SEEK_SET);
    unsigned int val;
    while (read(tmp_fd, &val, sizeof(val)) > 0) {
        printf("%u\n", val);
    }

    unlink(filename);
    return 0;
}
```

## Задачи из контеста Внедрение от Машечкина

### pr03-2

**Создание процессов**

На стандартном потоке ввода задается целое число `N` (`N` > 0). Требуется создать `N - 1` процессов так, чтобы первый процесс (процесс-родитель) вывел на стандартный поток вывода число `1`, второй процесс (его сын) вывел на стандартный поток вывода число `2`, третий процесс (сын сына) вывел `3` и так далее.

Вывод должен быть таким, чтобы всегда на стандартном потоке вывода оказывалась последовательность `1 2 3 ... N`, записанная в одну строку строго с одним пробелом между числами. В конце вывода должен находиться символ `\n`. Дополнительные пробелы в начале или конце строки не допускаются. Для вывода использовать средства высокого уровня.

Процесс-родитель должен завершаться самым последним из всех процессов.

Не используйте рекурсию!

### pr01-5

**Слияние файлов**

В аргументах командной строки задаются имена текстовых файлов, содержащих последовательности целых чисел в порядке неубывания.

На стандартный поток вывода напечатайте последовательность, составленную из всех чисел во входных последовательностях в порядке их неубывания.

Не используйте сортировку.

Не забывайте завершать вывод программы символом `\n`.

Каждый файл может быть открыт и прочитан не более одного раза.
