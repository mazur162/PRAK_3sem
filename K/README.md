# Все задачи комиссий по практикуму

*Примечание: во всех задачах, где используется динамическая память, нужно проверять возвращаемое значение `malloc` (сравнить с `NULL`). Такой тест всегда есть. (Если, конечно, в условии задачи не сказано, что памяти всегда хватает) - Волкова И.А.*

## 2015 - 2016

### K1-15-16-1

Описан тип звена списка

```c
struct Node { 
     struct Node *next;
     char *elem; 
};
```

Написать функцию

```c
struct Node *delete_all(struct Node *list, const char *str);
```

удаляющую из списка все звенья, содержащие указатели на строки, равные строке `str`, и освобождающую память, занимаемую этими звеньями и соответствующими строками.
Функция принимает указатель на начальное звено в списке и возвращает указатель на начальное звено после удаления. В списке нет заглавного звена. Поле `elem` в списке и параметр `str` никогда не равны `NULL`.

На проверку сдаётся только функция `delete_all` и необходимые для неё директивы `#include`. Определение структуры `Node` и функция `main` из сдаваемого на проверку файла должны быть удалены или закомментированы.

***Решение:***

```c
struct Node *delete_all( struct Node *list, const char* str) {
    struct Node* pred = list, *cur = list, *res = list;
    //проходим по начальным звеньям списка до первого звена,
    //которое не надо удалять
    while ((cur != NULL) && (strcmp(cur->elem, str) == 0)) {
        res = cur->next;
        free(cur->elem);
        free(cur);
        cur = res;
    }
    //поддерживаем два указателя - на предыдущий и
    //текущий элементы списка
    if (cur != NULL) {
        pred = cur;
        cur = cur->next;
    }
    while (cur != NULL) {
        if (strcmp(cur->elem, str)>0) {
            //удаляем звено и освобождаем память
            pred->next = cur->next;
            free(cur->elem);
            free(cur);
            cur = pred->next;
        } else {
            //просто переходим к следующему звену
            pred = pred->next;
            cur = cur->next;
        }
    }
    return res;
}
```

### K1-15-16-2

Программа должна обработать бинарный файл "`input.dat`", расположенный в текущем каталоге и содержащий 32-битные знаковые целые числа. Переставить в данном бинарном файле числа таким образом, чтобы сначала шли все отрицательные числа, а следом шли все неотрицательные числа. Порядок чисел одного знака неважен.
Для работы с файлом необходимо использовать функции низкоуровневого ввода-вывода. В памяти разрешается хранить не более 10 чисел из файла.
Программа должна завершать своё выполнение с кодом возврата `0`.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctype.h>

int 
main(void) {
    int fd;
    if ((fd = open("input.txt", O_RDONLY)) == -1) {
        exit(1);
    }
    char filename1[10] = "tmpXXXXXX";
    char filename2[10] = "tmpXXXXXX";
    int tmp1 = mkstemp(filename1);
    int tmp2 = mkstemp(filename2);

    int num;

    while (read(fd, &num, sizeof(num)) > 0) {
        if (num < 0) {
            write(tmp1, &num, sizeof(num));
        } else {
            write(tmp2, &num, sizeof(num));
        }
    }
    close(fd);
    if ((fd = open("input.txt", O_APPEND | O_TRUNC | O_RDWR)) == -1) {
        exit(1);
    }

    lseek(fd, 0, SEEK_SET);
    lseek(tmp1, 0, SEEK_SET);
    while (read(tmp1, &num, sizeof(num)) > 0) {
        write(fd, &num, sizeof(num));
    }
    lseek(tmp2, 0, SEEK_SET);
    while (read(tmp2, &num, sizeof(num)) > 0) {
        write(fd, &num, sizeof(num));
    }

    close(tmp1);
    close(tmp2);
    unlink(filename1);
    unlink(filename2);
    close(fd);
    return 0;
}

```

### K1-15-16-3

В аргументах командной строки программе передаются 3 параметра: `CMD1`, `CMD2` и файл `FILE3` (в указанном порядке). Реализуйте конвейер:
`CMD | CMD2 > FILE3`

Файл `FILE3` должен создаваться с правами на чтение и запись только для текущего пользователя. Основной процесс должен дожидаться завершения запущенных им процессов и только после этого завершаться с кодом возврата `0`.

***Решение:***

```c
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>

int main(int argc, char **argv) {
    pid_t pid;
    int file;

    file = open(argv[3], O_WRONLY | O_CREAT | O_TRUNC | O_RDONLY, 0600);

    int fd[2];
    pipe(fd);

    pid = fork();
    if (pid == 0) {
        dup2(fd[1], 1);
        close(fd[0]);
        close(fd[1]);
        execlp(argv[1], argv[1], NULL);
        exit(2);
    } else {
        dup2(fd[0], 0);
        dup2(file, 1);
        close(fd[0]);
        close(fd[1]);
        execlp(argv[2], argv[2], NULL);
        exit(3);
    }
    close(file);
    close(fd[0]);
    close(fd[1]);
    wait(NULL);
    return 0;
}

```

### K1-15-16-4

В аргументах командной строки программе передаются 2 параметра `CMD` и `N`. `CMD` - это имя другой программы для запуска, `N` - положительное целое число. Программа должна запустить на выполнение программу `CMD` в отдельное процессе.

Если программа `CMD` после запуска завершилась за `N` секунд, она должна быть завершена принудительно, и на стадартный поток вывода должна быть выдана строка
`Process #id terminated`,
где `#id` - это `PID` процесса.

Если программа `CMD` завершилась менее, чем за `N` секунд с кодом завершения `code`, на стандартный поток вывода должна быть выведена строка
`Process #id exited with code #code`

Если программа `CMD` завершилась менее, чем за `N` секунд из-за получения какого-нибудь сигнала `sig` на стандартный поток вывода должна быть выдана строка
`Process #id signaled by #sig`

В любом случае процесс-родитель должен завершаться сразу после завершения сына. Процесс-родитель должен завершаться с кодом `0`.

***Решение***:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/file.h>
#include <unistd.h>
#include <limits.h>
#include <sys/wait.h>
#include <errno.h>
#include <signal.h>

int pid_son;
void sig_hndr(int sig) {
    kill(pid_son, SIGINT);
    wait(NULL);
    printf("Process %d terminated\n", pid_son);
    exit(1);
}

int main(int argc, char** argv) {
    int N;
    sscanf(argv[1], "%d", &N);
    signal(SIGALRM, sig_hndlr);
    alarm(N);
    if (!(pid_son = fork()))
    {
        execvp(argv[2], argv[2]);
        exit(1);
    }
    int s;
    wait(&s);
    signal(SIGALRM, SIG_IGN);
    if (WIFEXITED(s)) {
        printf("Process %d exited with code = %d\n", pid_son, WEXITSTATUS(s));
        return 0;
    }
    if(WIFSIGNALED(s)) {
        printf("Proccess %d signaled by sig = %d\n", pid_son, WTERMSIG(s));
        return 0;
    }
    return 0;
}
```

### com04-1

В аргументах командной строки программе передаются вещественные числа `x1` и `x2` `(x2 > x1)` и целое число `n` `(n > 0)`. Процесс родитель должен создавать два сыновних проуесса `proc1` и `proc2`. Процессы обмениваются данными по следующей схеме.

Процесс `proc1` выводит на стандартный поток вывода цифру `"1"` и значение `x2`, затем отправляет по неименованному каналу процесс `proc2` число `x2`.

Процесс `proc2` выводит цифру `"2"`, затем пробел, затем число `cos(x`). После этого процесс `proc1` выводит на стандартный поток вывода цифру `"1"`, затем пробел, затем число `x2 - dx`, где `dx` - это `(x2 - x1) / n`, на третьей итерации - число `x2 - 2*dx` и так далее.

После вывода числа пересылаются в канал. Последним числом, записываемым в канал процесс `proc1`, должно быть число `x1`.

Родитель должен дождаться завершения работы сыновних процессов и сам завершить работу с кодом завершения `0`.

Для синхронизации процессов используйте только неименованные каналы. Вещественные числа вводите с 10 значащими десятичными цифрами. Учтите, что ваша программа будет выполняться с перенаправленным стандартным потоком вывода. В этом случае режим буферизации данных при выводе может отличаться от режима буферизации данным при выводе на терминал.

### com04-2

Дано определение типа звена односвязного списка строк

```c
struct ListNode {
     struct ListNode *next; /* указатель на следующее звено в списке */
     char *elem; /* указатель на C-строку в динамической памяти*/
}
```

Написать функцию

```c
struct ListNode *process_list(struct ListNode *list, const char *str);
```

Если значение элемента списка (поле `elem`) не равно строке `str` без учёта регистра букв, и если значение поля `elem` нескольких подряд идущих элементов списка равны без учёта регистра букв, то от всей серии равных элементов оставляется только один первый элемент, все остальные элементы удаляются. Если значение элемента списка равно `str` без учёта регистра букв, соответствующий элемент списка переставляется в голову списка.

Например, если параметр `str` равен `"B"`, то список `"B", "A", "A", "C", "B", "A", "A", "D", "B"` должен быть преобразован в `"B", "B", "B", "A", "C", "A", "D"`.

При удалении списка необходимо освобождать память, занимаемую элементов списка, так и хранящейся в нём строкой. Функция принимает указатель на начальное звено в списке и должна возвращать указатель на начальное звено модифицированного списка. В списке нет заглавного звена. Поле `elem` узлов списка и параметр `str` никогда не равны нулевому указателю.

На проверку сдаётся только функция `process` и необходимые для неё директивы `#include`. Определение структуры `ListNode` и функция `main` из сдаваемого на проверку файла должны быть удалены или закомментированы.

### com04-3

Напишите функцию `mant_size` с прототипом

```c
int mant_size(ling long value);
```

Функция должна вычислить размер мантиссы числа, то есть разность между номером самого старшего и нулевого бита в группе младших нулевых бит с номером самого старшего единичного бита числа. Например, размер мантиссы числа `1101000` равен `4`, размер мантиссы числа `100` равен `1`. Размер мантиссы числа `0` равен `0`, а размер мантиссы отрицательного числа равен размеру мантиссы соответствующего положительного числа.

### 2015_2016_k2_1

В аргументах командной строки программе передаются параметры

`CMD1` `CMD2` `CMD3` `FILE` (в указанном порядке). Реализуйте конвейер:

`CMD1 | CMD2 | CMD3 >> FILE`

 Файл должен создаваться с правами на чтение и запись только для текущего пользователя.

Основной процесс должен дожидаться выполнения созданных им процессов и только после этого завершиться с кодом возврата `0`.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

// cmd1 | cmd2 | cmd3 >> file


int main(int argc, char **argv) {
    int file;
    int fd[2];
    int gd[2];
    pipe(fd);

    if (!fork()) {
        dup2(fd[1], 1);
        close(fd[1]);
        close(fd[0]);
        execlp(argv[1], argv[1], NULL);
        exit(127);
    }
    close(fd[1]);

    pipe(gd);
    if (!fork()) {
        dup2(fd[0], 0);
        close(fd[0]);

        dup2(gd[1], 1);
        close(gd[1]);
        execlp(argv[2], argv[2], NULL);
        exit(127);
    }
    close(fd[0]);
    close(gd[1]);

    if (!fork()) {
        dup2(gd[0], 0);
        close(gd[0]);
        file = open(argv[4], O_WRONLY | O_APPEND | O_CREAT, 0600);
        dup2(file, 1);
        close(file);
        execlp(argv[3], argv[3], NULL);
        exit(127);
    }
    close(gd[0]);

    while (wait(NULL) > 0) {;}
    return 0;
}

```

### 2016_2017_K3_1

На стандартном потоке ввода задаются 2 целых числа `M` и `N` (1 <= M, N <= 256). Заполните массив размерности `M` и N числами от 1 до `M*N`, расположив их по спирали, закрученной по числовой стрелке, так, как показано на примере. Массив распечатайте на стандартный поток вывода.

Пример входных данных:

```txt
4 4 
```

Результат работы:

```txt
1  2  3 4

12 13 14 5

11 16 15 6

10  9  8 7
```

### 2015_2016_k3_2

Написать функцию

```c
int count(long long value)
```

которая возвращает количество единиц в двоичной записи числа value.

***Решение:***

```c
int count(long long value) {
    int c = 0;
    while (value > 0) {
        c += value % 2;
        value /= 2;
    }
    return c;
}
```

### 2015_2016_k3_3

Написать функцию удаляющую из списка str, и переставляющая, > str в конец списка

### com04-4

Программе передаются два аргумента командной строки: имя файла для обработки (`FILE`), затем число элементов для обработки (`N`). Файл для обработки - это бинарный файл, содержащий вещественные числа двойной точности. Размер файла всегда кратен размеру одного числа.

Если файл не содержит чисел или содержит только одно число, он не изменяется.

Если файл содержит более одного числа. `i`-е число в файле после обработки вычисляется по формуле `out[i] = 1.5 * in[i] + 0.5 * out[i - 1]`, где `out` - содержимое файла после обработки, а `in` - содержимое файла до обработки.

Число `N` определяет максимальное количество обрабатываемых чисел, то есть если в файле более `N` чисел, то обрабатываются первые `N` чисел, а остальные не изменяются. `in[0]` учитывается в числе `N`.

Таким образом, при `N`  < 1 входной файл вообще не изменяется.

Для работы с файлом необходимо использовать средства низкоуровневого ввода-вывода. Программа должна завершать своё выполнение с кодом возврата `0`.

Пример входных данных: `1 2 3 4 5 6 7 8 9`

Результат работы при `N` = 4 : `1 3.5 6.25 9.125 `

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char **argv) {
   // cоздаём файл
   // int fd = creat(argv[1], 0777);
   // for (int i = 1; i < 10; i++) {
      //  double a = (double) i;
      //  write(fd, &a, sizeof(a));
   // }
   // close(fd);
    fd = open(argv[1], O_RDONLY);
    double buff;
    // while (read(fd, &buff, sizeof(buff))) {
        // printf("in = %lf\n", buff);
    // пше}
    close(fd);
    fd = open(argv[1], O_RDWR);
    int N;
    double inp, out, pout;
    sscanf(argv[2], "%d", &N);
    if (N < 1) {
        exit(0);
    }
    read(fd, &pout, sizeof(pout));
    for (int i = 1; i < N; i++) {
        read(fd, &inp, sizeof(inp));
        out = 1.5 * inp + 0.5 * pout;
        lseek(fd, i * sizeof(double), 0);
        write(fd, &out, sizeof(out));
        pout = out;
    }
    close(fd);
    fd = open(argv[1], O_RDONLY);
    while (read(fd, &buff, sizeof(buff))) {
        printf("out = %lf\n", buff);
    }
    close(fd);
    return 0;
}
```

### 1

На стандартном потоке ввода вводится последовательность байт, записанных в шестнадцатеричной форме. Длина последовательности кратна 8. Каждые последовательные 8 байт входной последовательности преобразовываются в 8 байт выходной последовательности по следующим правилам. Пусть `a[i][j]` - это бит с номером `j` (0 - младший бит, 7 - старший бит) байта с номером `i` (от 0 до 7) в группе из 8 байт входного потока, `b[i][j]` - бит с номером `j` байта с номером `i` выходного потока. Для бит выходного потока должно выполняться условие `b[i][j] = a[j][i]`. Результат работы должен быть выведен побайтово в тестовом шестнадцатеричном представлении.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <ctype.h>
#include <math.h>

int
main(void) {
    int i, j;
    int flag = 0;
    char a[8][8], b[8][8];
    char filename[10] = "tmpXXXXXX";
    int tmp = mkstemp(filename);
    while (1) {
        for (i = 0; i < 8; i++) {
            char c0, c1;
            while (isspace(c1 = getchar())) {;}
            c0 = getchar();
            if (c0 == EOF && c1 == EOF) {
                flag = 1;
                break;
            }

            if (c0 >= 'A') {
                c0 = c0 - 'A' + 10;
            } else {
                c0 = c0 - '0';
            }

            if (c1 >= 'A') {
                c1 = c1 - 'A' + 10;
            } else {
                c1 = c1 - '0';
            }

            j = 0;
            while (j < 4) {
                a[i][7 - j] = c0 % 2;
                c0 = c0 / 2;
                j++;
            }
            while (j < 8) {
                a[i][7 - j] = c1 % 2;
                c1 = c1 / 2;
                j++;
            }
        }
        if (flag == 1) {
            break;
        }
        for (i = 0; i < 8; i++) {
            for (j = 0; j < 8; j++) {
                b[i][j] = a[j][i];
            }
        }
        for (i = 0; i < 8; i++) {
            int num_b = 0, k = 0;
            for (j = 7; j >= 0; j--) {
                num_b += b[i][j] * pow(2, k);
                k++;
            }
            lseek(tmp, 0, SEEK_END);
            write(tmp, &num_b, sizeof(num_b));
        }
    }

    int n;
    lseek(tmp, 0, SEEK_SET);
    while (read(tmp, &n, sizeof(n)) > 0) {
        printf("%d\n", n);
    }
    unlink(filename);

    return 0;
}
```

### 2

Звено двусвязного списка объявлено следующим образом:

```c
struct Elem {
    struct Elem *next, *prev;
    char *str;
};
```

Напишите функцию `process` с прототипом:

```c
struct Elem *process(struct Elem *head);
```

Функция `process` принимает указатель на голову закольцованного двусвязного списка (то есть списка, в котором звено, следующее за последним элементом - голова списка, а звено, предыдущее перед головой - хвост списка). Если в списке находятся несколько звеньев подряд с равными строками (полем `str`), оставьте только первое звено, а остальные удалите. При удалении звена должна удаляться память, занимаемая и звеном списка, и строкой. Таким образом, в списке-результате не должно быть равных звеньев, следующих подряд. В качестве результата функция должна вернуть указатель на звено, хранящее лексикографически максимальную строку. Если таких звеньев несколько, выбирается звено, находящееся ближе всего к голове при движении вперед. Указатель `str` звена списка никогда не равен `NULL`. Функции `process` может передаваться пустой список. Сдаваемый на проверку текст не должен содержать определения структуры `Elem` и функцию `main`.

***Решение:***

```c
Elem *process (Elem *head) {
    Elem *ptr;
    int size = 100;
    char *string = malloc(size * sizeof(char));
    ptr = head;
    do {
        if (strcmp(string, ptr->str) == 0) {
            (ptr->prev)->next = ptr->next;
            (ptr->next)->prev = ptr->prev;
            free(ptr->str);
            free(ptr);
        } else {
            if (strlen(ptr->str) > size) {
                size = size * 2;
                string = realloc(string, size * sizeof(char));
            }
            strcpy(string, ptr->str);
        }
        ptr = ptr->next;
    } while (ptr != head);
    ptr = head;
    Elem *max = ptr;
    do {
        if (strstr(max->str, ptr->str) >= 0) {
            max = ptr;
        }
        ptr = ptr->next;
    } while (ptr != head);
    return max;
}
```

### 3

Запустить процессы в конфигурации, эквивалентной следующей команде `shell`:

```c
(CMD1 && CMD2) | (CMD3 ; CMD4) > FILE5
```

Аргументы `CMD1`, `CMD2`, `CMD3`, `CMD4`, `FILE5` задаются в командной строке в указанном порядке. Для запуска используйте `fork` и `execlp`. Использовать `system` или `/bin/sh` или аналогичные высокоуровневые средства запрещеною Запись `A && B` означает, что сначала выполняется команда `A`, а затем, только если `A` завершилась успешно, выполняется команда `B`. Запись `A ; B` означает последовательное выполнение команд `A` и `B`.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int main (int argc, char **argv)
{
    int fd[2];
    pipe(fd);
    if (!fork())
    {
        dup2(fd[1], 1);
        close(fd[0]);
        close(fd[1]);
        if (!fork())
        {
            execlp(argv[1], argv[1], NULL);
            exit(1);
        }
        int s;
        wait(&s);
        if ((WIFEXITED(s) != 0) && (WEXITSTATUS(s) == 0))
        {
            execlp(argv[2], argv[2], NULL);
            exit(1);
        }
        exit(0);
    }

    if(!fork())
    {
        int f = open(argv[5], O_WRONLY | O_TRUNC | O_CREAT, 0777);
        dup2(fd[0], 0);
        dup2(f, 1);
        close(fd[1]);
        close(fd[0]);
        if (!fork())
        {
            execlp(argv[3], argv[3], NULL);
            exit(1);
        }
        wait(NULL);
        execlp(argv[4], argv[4], NULL);
        exit(1);
    }
    close(fd[1]);
    close(fd[0]);
    wait(NULL);
    wait(NULL);
    return 0;
}
```

### 4

Программе в аргументах командной строки задаются `FILE` - имя входного бинарного файла и `P` - количество процессов для обработки данных. Входной бнарный файл содержит 32-битные целые беззнаковые числа в представлении Little-Endian (LE). Главный процесс должен создать `P` процессов, которые должны **параллельно** обработать файл `FILE`. Процесс с номером `i` (считая, что процессы нумеруются от нуля) вычисляет сумму чисел по модулю 2^32 на позициях `i`, `P + i`, `2*P + i`, ... в файле (позиции нумеруются от 0). После окончания обработки файла все процессы выводят на стандартный поток вывода по очереди в порядке возрастания номеров процессов накопившиюся у каждого процесса сумму. Родитель дожидается завершения всех созданных им процессов, выводит на стандартный поток вывода число `0` и сам завершает свою работу с кодом завершения `0`. Для синхронизации процессов использовать семафоры.

## 2017

### com02-1

Звено двусвязного списка определено следующим образом:

```c
struct Elem {
    struct Elem *next, *prev;
    int count;
    char *str;
};
```

Напишите функцию `process` с прототипом:

```c
struct Elem *process(struct Elem *head);
```

Если поле `count` некоторого элемента списка больше `1`, то функция `process` должна сделать `count - 1` копий этого элемента списка и разместить новые элементы непосредственно после исходного элемента. Чтобы различить оригинальный и скопированные элементы к строке в скопированных элементах добавляется `-k`, где `k` изменяется от 2 и до `count`. После создания нужного количества копий элемента списка счётчик `count` устанавливается равным 1.

Гарантируется, что для любого элемента списка поле `count >= 1` и поле `str` не равно `NULL`.

Функция должна возвращать указатель на начало списка.

Пример.
Если на вход функции попадается список

`{{1, "a"}, {3, "b"}, {1, "c"}}`

Результатом работы должен быть список

`{{1, "a"}, {1, "b"}, {1, "b-2"}, {1, "b-3"}, {1, "c"}}`

### com02-2

В аргументах командной строки задаются:

`N` - число процессов для создания

`FILE1` - текстовый файл, содержащий последовательность 32-битных беззнаковых целых чисел в десятичной записи

`FILE2` - текстовый файл, содержащий последовательность 32-битных беззнаковых целых чисел в шестнадцатеричной записи. Каждое число начинается с начала строки и содержит ровно 8 знаков. Сразу после числа следует символ `\n`. Таким образом, длина каждой строки всегда равна 9.

Основной процесс должен создать `N` процессов, пронумерованных от `0` до `N - 1`. Главный процесс считывает по одному числу из файла `FILE1`. Остаток от деления считанного числа на `N` определяет номер `i` процесса-сына, который должен считать очередной число из файла `FILE2`, выполнить циклических сдвиг влево на `i` разрядов и выполнить побитовое сложение по модулю 2 с накапливаемым в этом процессе результатом. Процесс-сын должен считать только одно число, затем процесс-родитель определит следующего процесса-сына. Начальное значение при побитовом сложении в каждом процессе равно 0.

После чтения всех чисел из файла `FILE1`, процессы по очереди выводят результат вычислений. Результат должен выводиться как 32-битное беззнаковое целое значение в десятичной записи.

Главный процесс дожидается завершения работы всех порождённых процессов, выводит на стандартный поток вывода значение 0 и завершает свою работу.

При циклическом сдвиге влево на один разряд младшие 31 бит сдвигаются на один разря влево, а старший бит исходного числа переходит в младший бит числа результата.

Для синхронизации процессов использовать неименованные каналы.

### com-17-18-01-1

Напишите функцию `bit_reverse` со следующим прототипом:

```c
STYPE bit_reverse(STYPE value);
```

Где `STYPE` - это некоторый целый знаковый тип. Кроме того, определён и тип `UTYPE` - это некоторый целый беззнаковый тип того же размера, что и `STYPE`. Функция меняет порядок бит в числе на противоположный.

Например, рассмотрим 4-битное целое число `0101`. Поменяв порядок бит на противоположный, получим `1010`. Однако, если то же число рассматривать как 9-битовое, то обратный порядок бит будет равен `10100000`.

Сдаваемый на проверку текст должен содержать только функцию `bit_reverse`. Определения типов `STYPE` и `UTYPE` и функция `main` в нём находиться не должны.

### com-17-18-01-2

Программе передаются 3 аргументы командной строки:

`count` -  32-битное знаковое неотрицательное число

`modulo` - 32-битное знаковое положительное число

`prog` - имя программы для запуска

Программа (главный процесс `P0`) должна создать сына (процесс `P1`), который должен создать своего сына (процесс `P2`), главный процесс должен создать второго сына (процесс `P3`), который должен создать своего сына (процесс `P4`).

Процесс `P1` связаывается с процессом `P2` неименованным каналов в направлении от `P1` к `P2`.

Процесс `P2` связаывается с процессом `P4` неименованным каналов в направлении от `P2` к `P4`.

Процесс `P2` запускает с помощью `exec*p` на выполнение программу `prog`, соответствующим образом перенаправляя её стандартные потоки ввода-вывода.

Процесс `P1` генерирует `count` квадратов положительных целых чисел по модулю (то есть, остаток от деления) `modulo` и записывает их в канал. Например, последовательность первых 10 квадратов по модулю 10 равна `1 4 9 6 5 6 9 4 1 0`.

Процесс `P4` считывает данные, поступившие из своего канала и выводит их на стандартный поток вывода, заменяя символ пробела на символ `'\n'`.

Главный процесс ожитает окончания всей системы процессов, выводит на стандартный поток вывода число 0 и символ `'\n'` и завершает работу с кодом `0`.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/file.h>
#include <unistd.h>
#include <limits.h>
#include <sys/wait.h>
#include <errno.h>
#include <signal.h>

int main(int argc, char** argv)
{
    int fd12[2], fd24[2];
    int count, modulo;
    sscanf(argv[1], "%d", &count);
    sscanf(argv[2], "%d", &modulo);
    pipe(fd24);
    if (!fork())//P1
    {
        pipe(fd12);
        close(fd24[0]);
        if (!fork())//P2
        {
            close(fd12[1]);
            dup2(fd24[1],1);
            dup2(fd12[0],0);
            close(fd24[1]);
            close(fd12[0]);
            execlp(argv[3], argv[3], NULL);
            exit(1);
        }
        close(fd24[1]);
        close(fd12[0]);
  
        for(int i = 1; i <=count; i++ )
        {
            long long tmp1 = i*i;
            int tmp = (tmp1)%modulo;
            write(fd12[1], &tmp, sizeof(int));
        }
        close(fd12[1]);
        wait(NULL);
        exit(0);
    }
    if (!fork())//P3
    {
        close(fd24[1]);
        if (!fork())//P4
        {
            char c;
            while(read(fd24[0], &c, sizeof(char)))
            {
                if(c!=' ')
                     printf("%c", c);
                else
                     printf("%c", '\n');
                fflush(stdout);
            }
            close(fd24[0]);
            exit(0);
        }
        close(fd24[0]);
        wait(NULL);
        exit(0);
    }
    close(fd24[1]);
    close(fd24[0]);
    wait(NULL);
    wait(NULL);
    printf("%d\n",0);
    fflush(stdout);
    return 0;
}
```

### com-18-18-01-3

Программе в аргументах командной строки передаются имена файлов для обработки. Файлы могут содержать произвольные данные. Главный процесс должен создать по процессу на каждый обрабатываемый файл. Каждый процесс должен найти байт, который встречается чаще всего. Если таких байтов несколько, то выбирается меньший байт. Для каждого файла в аргументаз командной строки процесс родитель должен вывести на стандартный поток вывода значение наиболее часто встречающегося байта и число его повторений. Если файл пуст, то выводится два нуля. Значения должны выводиться в том же порядке, в котором заданы имена файлов в командной строке.

Затем главный процесс получает от каждого процесса число повторений символа, который оказался наиболее частым в следующем по порядку файле. То есть, первый процесс сообщает родителю частоту повторений в первом файле того символа, который оказался наиболее частым по втором файле. Последний процесс берет наиболее частый символ первого файла. Если следующий по порядке файл оказался пустым, то процесс передает родителю значение `0`. Главный процесс выводит на стандартный поток вывода полученные от сыновей числа в порядке следования файлов в командной строке.

Главный процесс дожидается окончания выполнения всех процессов и завершает работу с кодом `0`. Для синхронизации и передачи файлов используйся семафоры и разделяемую память. Все объекты синхронизации должны быть уничтожены.

## 2018

### com02-1

Элемент двухсвязного списка описывается структурой `ListItem`:

```c
struct ListItem {
    struct ListItem *prev, *next;
    unsigned char *str;
}
```

```c
void process (struct ListItem *head, const unsigned char *prefix);
```

Напишите функцию `process`, которая принимает указатель на голову списка и строку для поиска. Функция просматривает элементы списка последовательно от начала к концу. Если у некоторого элемента  списка строка `str` начинается с префикса `prefix`, сразу после которого следует число `N`, записанное в десятичной системе без знаков `+` или `-`, имеющее значение от 1 до 255 (включительно), из списка должны быть удалены `N` элементов, непосредственно следующих за текущим обрабатываемым элементом, либо все оставшиеся элементы списка, если их меньше `N`. После этого функция переходит к просмотру элемента следующего за удалённым. Если строка `str` не удовлетворяет требованиям, описанным выше, то функция переходит к просмотру следующего элемента. Память, занимаемая удаленными элементами, должна быть корректно освобождена.

Например, если задана строка префикса `A`, а некоторый элемент списка хранит строку `A10`, то десять следующих после этого элемента элементов списка должны быть удалены.

Если элемент списка содержит строку `a2b`, то она считается не удовлетворяющей требованиям.

Программа, сдаваемая на процерку, должна содержать определение структуры `ListItem` и функцию `process`. Параметр `prefix` и поле `str` никогда не равны `NULL`.

***Решение:***

```c
void process(struct ListItem *head, unsigned char *prefix) {
	struct ListItem *ptr = head;
	while (ptr != NULL) {
		unsigned char *podstr;
		if ((podstr = strstr(ptr->str, prefix)) != NULL) {
			if (podstr == ptr->str) {
				podstr += strlen(prefix);
				char *strend;
				int num = strtol(podstr, &strend, 10);
				if (*strend == '\0') {
					int count = 0;
					while (count < num && ptr->next != NULL) {
						struct ListItem *del = ptr->next;
						ptr->next = del->next;
						if (del->next != NULL) {
							del->next->prev = ptr;
						}
						free(del->str);
						free(del);
						count++;
					}
				}
			}
		}
		ptr = ptr->next;
	}
}
```

### com02-2

Программе в аргументах командной строки передаются два имени программы `PROG1` и `PROG2` для запуска.

Главный процесс (процесс 0) создаёт 3 сыновей (процессы 1, 2 и 3). Процессы 1 и 3 создают своих сыновей (процессы 4 и 5 соответсвенно). Процесс 4 связывается неименованным каналом с процессом 2 (от процесса 4 к процессу 2), и процесс 2 связывается неименованным каналом с процессом 5 (от 2 к 5). В процессе 4 на выполнение запускается программа `PROG1`, в процесссе 5 - программа `PROG2`. Программы запускаются с помощью `exec*`.

Процессу 2 от процесса 4 поступает поток 32-битных знаковых чисел в текстовом виде. Числа разделяются пробельными символами. Процесс 2 должен передать процессу 5 только четные целые числа в текстовом виде, разделяя их символом перевода строки.

Главный процесс должен дождать завершения работы всей системы процессов, после чего завершиться с кодом `0`.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <ctype.h>


int main(int argc, char **argv) {
    pid_t p1, p2, p3, p4, p5;
    int fd42[2], fd25[2];
    pipe(fd42);
    pipe(fd25);
  
    if ((p1 = fork()) == 0) {
        if ((p4 = fork()) == 0) {
            dup2(fd42[1], 1);
            close(fd42[0]);
            close(fd42[1]);
            execlp(argv[1], argv[1], NULL);
            exit(127);
        }
        close(fd42[0]);
        close(fd42[0]);
        wait(NULL);
        return 0;
    }
  
  
    if ((p2 = fork()) == 0) {
        close(fd42[1]);
        close(fd25[0]);
        int len = 0;
        char c, buf[34];
        while (read(fd42[0], &c, 1) > 0) {
            if (isspace(c)) {
                buf[len] = '\n';
                if (len > 0 && buf[len - 1] % 2 == 0) {
                    write(fd25[1], buf, len + 1);
                }
                len = 0;
            }
            if (c >= '0' && c <= '9') {
                buf[len] = c;
                len++;
            }
        }
        buf[len] = '\n';
        if (len > 0 && buf[len - 1] % 2 == 0) {
            write(fd25[1], buf, len + 1);
        }
        close(fd42[0]);
        close(fd25[1]);
        return 0;
    }
  
    if ((p3 = fork()) == 0) {
        if ((p5 = fork()) == 0) {
            dup2(fd25[0], 0);
            close(fd25[0]);
            close(fd25[1]);
            execlp(argv[2], argv[2], NULL);
            exit (127);
        }
        close(fd25[0]);
        close(fd25[1]);
        wait(NULL);
        return 0;
    }
  
    close(fd25[0]);
    close(fd25[1]);
    close(fd42[0]);
    close(fd42[1]);
    wait(NULL);
    wait(NULL);
    wait(NULL);
  
    return 0;
}

```

### com02-3

Программа должна вывести на стандартный поток вывода свой `PID` и переключиться в режим ожидания поступления сигнала. Каждое поступление сигнала `SIGUSR1` увеличивает значение счётчика на 5. Каждое поступление сигнала `SIGUSR2` уменьшает значение счётчика на 4. Начальное значение счётчика - 32-битового целого числа - равно 0. При поступлении любого из этих сигналов на стандартный поток вывода выводится номер сигнала (значение константы `SIG*`) и значение счётчика после изменения.

Если значение счётчика стало отрицательным, программа завершает работу с кодом завершения `0` после вывода значений. Стандартный ввод и стандартный вывод программы будут перенаправлены. С другой стороны каналов находится другой процесс, поторый начнет свою работу, как только получит `pid` процесса.

Например, если программе отправляются сигналы `SIGUSR1`, `SIGUSR2`, `SIGUSR2`, то программа должна вывести

```
10 5
12 1
12 -3
```

***Решение:***

```c
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>

int counter = 0;

void sighndlr(int s) {
	signal(SIGUSR1, sighndlr);
	signal(SIGUSR2, sighndlr);
	if (s == SIGUSR1) {
		counter += 5;
	} 

	if(s == SIGUSR2) {
		counter -= 4;
	}
	printf("%d %d\n", s, counter);
	fflush(stdout);
}

int main (void) {
	signal(SIGUSR1, sighndlr);
	signal(SIGUSR2, sighndlr);

	printf("%d\n", getpid());

	pid_t p;
	if ((p = fork()) == 0) {
		while (1) {
			usleep(123456);
			if (counter < 0) {
				break;
			}
		}
		exit(0);
	}
	kill(p, SIGUSR1);
	usleep(123456);
	kill(p, SIGUSR2);
	usleep(123456);
	kill(p, SIGUSR2);

	int status;
	wait(&status);
	if(WIFEXITED(status)) {
		printf("%d\n", 	WEXITSTATUS(status));
	}
	if (WIFSIGNALED(status)) {
		printf("%d\n", 	128 + WTERMSIG(status));
	}
	return 0;
}



```

### 2014_2015_k2_4.

Программа должна напечатать на стандартный поток вывода свой `pid`.

Затем программе на стандартном потоке ввода подаются целые числа. В зависимости от режима работы для каждого введенного числа на стандартный поток вывода программа выводит либо число, взятое с обратным знаком, либо квадрат числа.

При получении сигнала `SIGUSR1` программа переключается в режим взятия обратного знака числа. При получении сигнала `SIGUSR2` программа переключается в режим возведения числа в квадрат. В начале работы программа работает в режиме взятия обратного знака числа.

Стандартный ввод и стандартный вывод программы будут перенаправлены. Не забывайте сбрасывать буфер вывода с помощью функции `fflush(stdout)`.

С другой стороны каналов находится другой процесс, который начнет свою работу, как только получит `pid` процесса.

### km01-1

**UART** (Universal Asynchronous Receiver-Transmitter) - это протокол, позволяющий передавать данные по последовательной линии в одной направлении от отправителя к получателю. Когда данные не передаются, на линии установлено напряжение логической единицы, что считается приёмным устройством как единичный бит. Чтобы начать передачу отправитель передает один нулевой бит (так называемый старт-бит), за которым идут 8 бит данных в порядке от младшего бита к старшему, за которыми идёт бит паритета, равный 1, если в переданных 8 битахданных чётное число единиц, и равный 0, еслив них нечётное число единиц. Передачу завершает стоп-бит, всегда равный 1, который снова переводит линию в состояние ожидания новых данных. Таким образом, октеты данных передаются пакетами из 11 бит.

На стандартный поток ввода вашей программы подаётся состояние входной линии (символ `'0'` обозначает логический ноль, '`1'` - логическую единицу). Кроме того, для удобства записи, символы могут разделяться произвольным количеством пробельных (в смысле функции `isspace`) символов. На стандартный поток вывода выведите декодированные из входного потока октеты. Ваш ответ должен совпадать с правильным побитово. Не выводите никаких посторонних символов. Поток данных имеет правильную структуру фреймов, но бит паритета может не совпадать. Если у принятого октета не совпадает бит паритета, выводите символ `'?'` (знак вопроса).

### km01-2

Программе в аргументах командной строки передаётся начальная скорость (32-битное целое знаковое число). Ваша программа должна промоделировать работу цифрового спидометра.

Цифровой спидометр должен обрабатывать прерывания от таймера, которые будут моделироваться с помощью сигнала `ALRM`. Сигналы `USR1` и `USR2` поступают от акселерометра, `USR1` означает, что скорость увеличилась на одну единицу, а `USR2` означает, что что скорость уменьшилась на одну единицу. По сигналу `TERM` программа должна вывести на стандартный поток вывода пройденное расстояние (на момент последнего обработанного `ALRM`) и завершить работу.

Все единицы измерения (время между прерываниями от таймера, скорость, ускорение) согласованы друг с другом, то есть никаких масштабных коэффициентов не требуется.

Стандартный ввод и стандартный вывод программы будут перенаправлены в каналы. Не забывайте сбрасывать буфер вывода. С другой стороны каналов находится другой процесс, который начнёт свою работу как только получит `pid` процесса. Предполагайте, что от вывода `pid` до прихода первого `ALRM` приходит одна единица времени.

Указание: используйте отдельную функцию-обработчик для каждого сигнала.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/file.h>
#include <unistd.h>
#include <limits.h>
#include <sys/wait.h>
#include <errno.h>
#include <signal.h>

int speed;
int dist = 0;

void SigUser1 (int sig)
{
    if (sig = SIGUSR1)
    {
        speed++;
    }
}

void SigUser2 (int sig)
{
    if (sig = SIGUSR2)
    {
        speed--;
    }
}

void SigTerm (int sig)
{
    if (sig = SIGTERM)
    {
        printf("%d\n", dist);
        exit(0);
    }
}

void SigAlrm (int sig)
{
    if (sig = SIGALRM)
    {
        dist += speed;
    }
}

int main (int argc, char **argv)
{
    signal(SIGUSR1, SigUser1);
    signal(SIGUSR2, SigUser2);
    signal(SIGTERM, SigTerm);
    signal(SIGALRM, SigAlrm);

    printf("%d\n", getpid());

    sscanf(argv[1], "%d", &speed);

    while (1)
    {
        alarm(1);
        sleep(1);
    }
}
```

### km01-3

В данной задаче вам предлагается промоделировать память с расслоением по банкам.

В аргументах командной строки задаются имена бинарных файлов, хранящие содержимое банков памяти. Главная программа запускает по одному процессу на каждый банк памяти и обменивается данными с ними с помощью разделяемой памяти и семафоров.

Главная программа считывает со стандартного потока ввода адреса ячеек памяти, каждая ячейка памяти имеет размер 8 бит. Главная программа определяет номер банка, в котором находится эта ячейка, отправляет запрос в соответствующий процесс (банк памяти), дожидается ответа и выводит содержимое соответствующей ячейки памяти на стандартный поток вывода как целое число от 0 до 255.

Можете предполагать, что все файлы с содержимым банков памяти имеют одинаковый размер. Адреса ячеек в памяти представляются беззнаковыми 32-битными целыми числами. Если ячейки с указанным адресом не существует, на стандартный поток вывода должно быть напечатано число `-1`.

При завершении программы все объекты, использованные для обмена информацией между процессами, должны быть удалены.

### 2018_2019_km02-1

Напишите программу. На стандартном потоке ввода задаются две строки текста. Каждая из строк представляет собой запись восьмеричного числа длиной не более чем `1000` цифр. Другие символы, кроме символов восьмеричных цифр в строках отсутствуют. На стандартный поток вывода напечатайте восьмеричное число, являющееся результатом применения операции побитого суммирования по модулю `2` к исходным числам. В напечатанном числе не должно быть незначащих ведущих нулей.

### 2018_2019_km02-2

Структура звена односвязного списка определена следующим образом:

```с
struct List

{

  struct List *next;

  char *data;

};
```

Напишите функцию

```c
struct List *remove_elems(struct List *lst);
```

Функция на вход принимает указатель на начало циклического списка (то есть, поле `next` последнего элемента указывает на первый элемент). Функция `remove_elems` должна изъять из списка и уничтожить звенья списка, строки `data` в которых являются корректной записью 32-битного целого знакового числа в десятичной системе счисления.

Пробельные символы допускаются перед числом, но не после него. Функция должна вернуть указатель на голову списка или `NULL`.

### 2018_2019_km02-3

Напишите программу. В аргументах командной строки задаются имена программ для запуска. Эти программы должны быть запущены на выполнение параллельно с помощью функции `execlp`. Каждая программа в качестве результата выдает на стандартный поток ввода одну строку текста, завершающуюся символом `'\n'`.

Длина строки текста (без учета `'\n'`) не превышает `4094` байт. Главная программа должна обработать результаты работы запущенных программ следующим образом: отсортировать строки в порядке лексикографического убывания и вывести результат на стандартный поток вывода.

## 2019

### km01-1

В аргументах командной строки задаются имя входного бинарного файла (`FILE1`), имя выходного бинарного файла (`FILE2`) и положительное 32-битное знаковое число (`MOD`). Файл `FILE1` содержит множество последовательных целых чисел, представленное в виде битового вектора. Бит 0 (младший бит первого байта) в файле соответствует числу 1, бит 7 (старший бит первого байта ) в файле соответсветсвует числу 8 и т.д. Установленный бит означает, что соответствующее число присутсвует во множестве. Для каждого числа `x`, присутсвующего во множестве, хранящегося в `FILE1`, в бинарный файл `FILE2` запишите 32-битное знаковое целое число

<img src="https://latex.codecogs.com/svg.image?(\sum_{i=1}^{x}&space;i^2)&space;\;&space;mod&space;\;&space;MOD" title="(\sum_{i=1}^{x} i^2) \; mod \; MOD" />

, то есть остаток от деления на `MOD `суммы квадратов всех чисел от 1 до `х `включительно. Числа должны быть записаны в порядке возрастания значения `х`. Для работы с файлами использовать интерфейс системных вызовов.

Например, если входной бинарный файл содержит байт `0x93`, и значение `MOD` равно `1000`, то в выходной бинарный файл должны быть записаны числа `1, 2, 55, 204`.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/file.h>
#include <unistd.h>
#include <limits.h>
#include <sys/wait.h>
#include <errno.h>
#include <signal.h>
int main(int argc, char** argv)
{
    int mod;
    sscanf(argv[3], "%d", &mod);
    int f1 = open(argv[1], O_RDONLY);
    int f2 = open(argv[2], O_WRONLY | O_APPEND | O_CREAT, 0666);
    int x = 1;
    unsigned char b, c;
    while(read(f1, &c, 1)) {
        while(c > 0) {
            if (c & 1) {
                int s = 0;
                for(int i = 1; i <= x; i++)
                    s = s + i*i;
                s = s % mod;
                write(f2, &s, sizeof(int));
                printf("%d ", s);
            }
            c = c >> 1;
            x++;
        }
    }
    printf("\n");
    return 0;
}
```

### km01-2

Отец (процесс `P0`) порождает двух сыновей (`P1`, `P2`). Процесс `P1` порождает своего сына (`P3`), то есть внука процесса `P0`. Процессы связываются неименованными каналами `P3 -> P2`, `P2 -> P3`, `P1 -> P3`. Обмен данными в каналах ведется парами 64-битных знаковых целых чисел. Изначально процесс `P0` записывает процессу `P3` два числа `1`. После этого начинает работать передача данных по кругу (`P3 -> P2 -> P1 -> P3 -> ...`). Каждый процесс считывает из входного канала пару чисел (обозначим `A` и `B`), выводят свой порядковый номер (`1`, `2`, `3`) и два считанных числа из стандартного потока ввода, записывает в выходной канал числа `B`, `A + B`. Передача данных заканчивается, когда считанное число `B` превосходит значение заданное в командной строке. В этом случае ничего выводить не нужно. Для взаимодействия процессов использовать только неименованные каналы и `wait`. Процесс `P0` долден завершиться последним с кодом завершения `0`.

Например, если в аргументе командной строки указано `10`, то на стандартный поток вывода должно быть напечатано:

```
2 1 1
2 1 2
1 2 3
3 2 5
3 5 8
```

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>

int main (int argc, char ** argv)
{
    int fd32[2];
    int fd21[2];
    int fd13[2];
    pipe(fd32);
    pipe(fd21);
    pipe(fd13);
    long long count;
    scanf("%lld", &count);
    long long a = 1, b = 1;
    int pid1, pid2, pid3;

    if ((pid1 = fork()) == 0)
    {
        if ((pid3 = fork()) == 0)
        {
            close(fd21[1]);
            close(fd21[0]);
            close(fd13[1]);
            close(fd32[0]);
            while (1) {
                read(fd13[0], &a, sizeof(long long));
                read(fd13[0], &b, sizeof(long long));
  
                if (b > count) {
                    write(fd32[1], &a, sizeof(long long));
                    write(fd32[1], &b, sizeof(long long));
                    close(fd13[0]);
                    close(fd32[1]);
                    break;
                }
                printf("3 ");
                printf("%lld %lld\n", a, b);
                a = a + b;
                write(fd32[1], &b, sizeof(long long));
                write(fd32[1], &a, sizeof(long long));
            }
            exit(0);
        }
        close(fd32[0]);
        close(fd32[1]);
        close(fd21[1]);
        close(fd13[0]);
        while (1) {
            read(fd21[0], &a, sizeof(long long));
            read(fd21[0], &b, sizeof(long long));
            //printf("%lld %lld \n", a, b);
            if (b > count)
            {
                write(fd13[1], &a, sizeof(long long));
                write(fd13[1], &b, sizeof(long long));
                close(fd21[0]);
                close(fd13[1]);
                break;
            }
            printf("1 ");
            printf("%lld %lld\n", a, b);
            a = a + b;
            write(fd13[1], &b, sizeof(long long));
            write(fd13[1], &a, sizeof(long long)); 
        }
        wait(NULL);
        exit(0);

    }
    if ((pid2 = fork()) == 0) {
        close(fd13[0]);
        close(fd13[1]);
        close(fd32[1]);
        close(fd21[0]);
        while (1) {
            read(fd32[0], &a, sizeof(long long));
            read(fd32[0], &b, sizeof(long long));
            if (b > count) {
                write(fd21[1], &a, sizeof(long long));
                write(fd21[1], &b, sizeof(long long));
                close(fd32[0]);
                close(fd21[1]);
                break;
            }
            printf("2 ");
            printf("%lld %lld\n", a, b);
            a = a + b;
            write(fd21[1], &b, sizeof(long long));
            write(fd21[1], &a, sizeof(long long));
        }
        exit(0);
    }
    write(fd13[1], &a, sizeof(long long));
    write(fd13[1], &b, sizeof(long long));
    close(fd13[0]);
    close(fd13[1]);
    close(fd21[0]);
    close(fd21[1]);
    close(fd32[0]);
    close(fd32[1]);
    wait(NULL);
    wait(NULL);
    return(0);
}
```

### km01-3

Программа должна создать три процесса. Первый созданный процесс должен обрабатывать только `IPv4`-адреса класса `А`, второй процесс - только `IPv4`-адреса класса `B`, третий процесс - только `IPv4` адреса класса `C`. Каждый из этих процессов извлекает из адреса номер сети и печатает класс сети (A, B или C) и номер сети на стандартный поток вывода в шестнадцатеричном виде. Процесс-родитель считывает со стандартного потока ввода `IP`-адреса,  записанные в десятично-точечной нотации, и передает их на обработку соответствующему процессу-сыну. Для передачи данных должна использоваться разделяемая память и семафоры. Когда отец достигает конца стандартного потока ввода, сначала должны завершиться процессы-сыновья, затем процесс-отец. Созданные объекты `IPC` должны быть уничтожены.

| `Пример входных данных` | `Результат работы` |
| -------------------------------------------- | ----------------------------------- |
| `4.57.256.36`                              | `A 4`                             |
| `130.44.124.158`                           | `B 22c`                           |
| `200.51.236.160`                           | `C 633ee`                         |

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/file.h>
#include <unistd.h>
#include <limits.h>
#include <sys/wait.h>
#include <errno.h>
#include <signal.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/ipc.h>

int main(int argc, char** argv)
{
    unsigned a1,a2,a3,a4;
    int pid1, pid2, pid3;
    char c;
    int key = 1234;
    char *shmaddr;
    struct sembuf op;
    int shmid = shmget(key, 256, 0666|IPC_CREAT);
    int semid = semget(key, 3, 0666|IPC_CREAT);
    shmaddr = shmat(shmid, NULL, 0);
    semctl(semid, 0, SETALL, (int)0);
  
    if(!(pid1 = fork()))
    {
        shmid = shmget(key, 256, 0);
        semid = semget(key, 3, 0);
        shmaddr = shmat(shmid, NULL,0);
        op.sem_num = 0;
        op.sem_flg = 0;
        op.sem_op = -1;
        printf("A\n");
        while(semop(semid, &op, 1)!=-1)
        {
            sscanf(shmaddr, "%u %u %u", &a1, &a2, &a3);
            printf("A %u %u %u\n", a1, a2, a3);
            unsigned char a11 = a1;
            a11 = a11 << 1;
            a11 = a11 >> 1;
            printf("A %x\n", a11);
            semop(semid, &op, 1);
        }
        shmdt(shmaddr);
        exit(0);
    }
    if(!(pid2 = fork()))
    {
        shmid = shmget(key, 256, 0);
        semid = semget(key, 3, 0);
        shmaddr = shmat(shmid, NULL,0);
        op.sem_num = 1;
        op.sem_flg = 0;
        op.sem_op = -1;
        printf("B\n");
        while(semop(semid, &op, 1)!=-1)
        {
            sscanf(shmaddr, "%u %u %u", &a1, &a2, &a3);
            printf("B %u %u %u\n", a1, a2, a3);
            unsigned char a11 = a1, a22 = a2;
            a11 = a11 << 2;
            a11 = a11 >> 2;
            printf("B %x%x\n", a11, a22);
            op.sem_op = -1;
            semop(semid, &op, 1);
        }
        shmdt(shmaddr);
        exit(0);
    }
    if(!(pid3 = fork()))
    {
        shmid = shmget(key, 256, 0);
        semid = semget(key, 3, 0);
        shmaddr = shmat(shmid, NULL,0);
        op.sem_num = 2;
        op.sem_flg = 0;
        op.sem_op = -1;
        printf("C\n");
        while(semop(semid, &op, 1)!=-1)
        {
            sscanf(shmaddr, "%u %u %u", &a1, &a2, &a3);
            printf("C %u %u %u\n", a1, a2, a3);
            unsigned char a11 = a1, a22 = a2, a33 = a3;
            a11 = a11 << 3;
            a11 = a11 >> 3;
            printf("C %x%x%x\n", a11, a22, a33);
            op.sem_op = -1;
            semop(semid, &op, 1);
        }
        shmdt(shmaddr);
        exit(0);
    }
    while(scanf("%u%c%u%c%u%c%u", &a1, &c, &a2, &c, &a3, &c, &a4) == 7)
    {
        printf("%u %u %u %u\n", a1, a2, a3, a4);
        sprintf(shmaddr, "%u %u %u", a1, a2, a3);
        if (a1<=127)
        {
            op.sem_num = 0;
            op.sem_flg = 0;
            op.sem_op = 2;
            semop(semid, &op, 1);
            op.sem_op = 0;
            semop(semid, &op, 1);
        }
        else
        {
            if (a1 >=128 && a1<=191)
            {
                op.sem_num = 1;
                op.sem_flg = 0;
                op.sem_op = 2;
                semop(semid, &op, 1);
                op.sem_op = 0;
                semop(semid, &op, 1);
            }
            else
            {
                if (a1 >=192 && a1<=223)
                {
                    op.sem_num = 2;
                    op.sem_flg = 0;
                    op.sem_op = 2;
                    semop(semid, &op, 1);
                    op.sem_op = 0;
                    semop(semid, &op, 1);
                }
            }
        }
    }

    shmdt(shmaddr);
    shmctl(shmid, IPC_RMID, NULL);
    semctl(semid, 0, IPC_RMID, (int)0);
    wait(NULL);
    wait(NULL);
    wait(NULL);
    return 0;
}
```

## 2020

### km02-1

Структура элемента списка определена следующим образом:

```c
struct ListItem {
    struct ListItem *next;
    char *str;
};
```

Напишите функцию со следующим прототипом:

```c
struct ListItem *list_dup(const struct ListItem *list);
```

Функция должна вернуть новый список строк, который содержит строки исходного списка, которые состоят только из строчных латинских букв. В выходном списке строки должны следовать в обратном порядке к тому, в котором строки находятся в исходном списке.

Например, если на вход функции подан список `{"a", "1", "b", "2", "C"}`, на выходе должен быть получен список `{"b", "a"}`.

Сдаваемый на проверку код должен содержать определение структуры `ListItem` и тело функции `list_dup`.

***Решение:***

```c
struct ListItem {
    struct ListItem *next;
    char *str;
};

struct ListItem *list_dup(const struct ListItem *list) {
    struct ListItem *begin = NULL, *tmp;
    int flag = 1;
    while (list != NULL) {
        for (int i = 0; i< strlen(list->str); i++) {
            if(list->str[i] < 'a' || list->str[i] >'z') {
                flag = 0;
                break;
            }
        }
        if (flag) {
            tmp = (struct ListItem *)malloc(sizeof(struct ListItem));
            tmp->str = (char*)malloc(strlen(list->str)+1);
            strcpy(tmp->str, list->str);
            tmp->next = begin;
            begin = tmp;
        }
        flag = 1;
        list=list->next;
    }
    return begin;
}
```

### km02-2

Программе предаётся два аргумента командной строки: имя бинарного файла `FILE` и положительное целое число `N`. Бинарный файл содержит 64-битные целые числа, но может быть пустым. В этом файле переставить числа, которые находятся на позициях `0`, `N`, `2N`, `3N`, ... и так далее до конца файла, в обратном порядке.

Например, при `N == 2` в содержимом файла `{1, 2, 3, 4, 5}` в результате должен получиться файл `{5, 2, 3, 4, 1}`.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/file.h>
#include <unistd.h>
#include <limits.h>
#include <sys/wait.h>
#include <errno.h>
#include <signal.h>

int main(int argc, char** argv)
{
    int fd;
    fd = open(argv[1], O_WRONLY|O_CREAT|O_TRUNC, 0666);
    long long tmp;
    for(int i = 1; i< 6; i++)
    {
        tmp = (long long) i;
        write(fd, &tmp, sizeof(long long));
    }
    close(fd);
  
    fd = open(argv[1], O_RDONLY);
    while(read(fd, &tmp, sizeof(long long)))
    {
        printf("%lld ", tmp);
    }
    printf("\n");
    close(fd);
  
  
    long long first, second;
    long long len, pos=0;
    fd = open(argv[1], O_RDWR);
    len = lseek(fd,0,2)/sizeof(long long);
    lseek(fd,0,0);
    int N;
    sscanf(argv[2], "%d", &N);
    long long back = len - len%N;
    for (int i = 0; i < len/2; i++) {
        if (i % N == 0) {
            read(fd, &first, sizeof(long long));
            pos = lseek(fd,0,1) - sizeof(long long);
            lseek(fd, back*sizeof(long long), 0);
            read(fd, &second, sizeof(long long));
            lseek(fd, -sizeof(long long), 1);
            write(fd, &first, sizeof(long long));
            lseek(fd, pos, 0);
            write(fd, &second, sizeof(long long));
            lseek(fd, pos+ N*sizeof(long long), 0);
            back = back-N;
        }
    }
    close(fd);
  
  
    fd = open(argv[1], O_RDONLY);
    while(read(fd, &tmp, sizeof(long long))) {
        printf("%lld ", tmp);
    }
    printf("\n");
    close(fd);
  
    return 0;
}
```

### km03-1

На стандартный поток ввода задаются два числа: `a` - 64-битное знаковое целое число в десятичном виде и `b` (`1 < b < 1000`) основание системы счисления - целое число в десятичном виде.

На стандартный поток вывода напечатайте сумму цифр числа `a`, записанного в системе счисления по основанию `b`. Сумму цифр выведите в десятичной системе счисления. Число `a` может быть отрицательным.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>

int main (void)
{
    long long aa;
    unsigned long long a;
    unsigned b;
    unsigned long long sum = 0;
    scanf("%lld %u", &aa, &b);
    a = labs(aa);
    printf("%llu\n", a);
    printf("%u\n", b);
    while (a  != 0)
    {
        sum += a % b;
        printf("%llu\n", a % b);
        a = a /  b;  
    }
    printf("%llu\n", sum);

    return 0;
}
```

### km03-2

Дана функция `proc`:

```c
int proc(void) {
    int pid = fork();
    if (!pid) {
        write(1, "1\n", 2);  
    }
    return pid;
}
```

Запишите **одно выражение** на языке C, в результате выполнения которой на стандартный поток вывода строка 1 была бы выведена 7 раз. В качестве программы сдайте `main`, содержащий только это выражение. В выражении можно использовать только операции языка Си и вызывать функцию `proc()` не более 4 раз.

***Решение:***

```c
int k = proc() + proc() +  proc();
```

### km03-3

На стандартном потоке ввода подаётся последовательность символов, которая заканчивается с признаком конца ввода. Словом назовём последовательность строчный латинских букв ('a', ..., 'z'), идущих в тексте подряд, и максимально возможной длины.

То есть, текст `"abcd"` содержит слово `"abcd"`, а не, например, два слова `"a"` и `"bcd"`. На стандартный поток вывода напечатайте длину самого длинного слова в тексте, не содержащего букву `'q'`. Если такого слова нет, выведите `0`.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main (void)
{
    char c;
    unsigned count = 0;
    unsigned max = 0;
    while ((c = getchar()) != EOF) {
        if ('a'<= c && c <= 'z') {
            if (c != 'q') {
                count++;
                if (count > max) {
                    max = count;
                }
            }
            else
            {
                count = 0;
            }
            printf("%u", count);
        } else {
            count = 0;
        }
    }
    printf("\n");
    printf("max = %u\n", max);
}
```

### km03-4

В аргументах командной строки передаются числа в восьмеричной системе счисления в диапазоне от 1 до 64 (включительно), разделенные символом `','` (запятая). Рассматривайте эти числа как элементы множества в котором каждое число представляется одним битом, представляя множество в виде 64-битного беззнакового числа и на стандартный поток вывода выведите это число в шестнадцатеричном виде.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>


int main(int argc, char **argv)
{
    unsigned int arr[64] = {0};
    for (int i = 1; i < argc; i = i + 2) {
        int tmp;
        sscanf(argv[i], "%o", &tmp);
        arr[tmp - 1] = 1;
    }
    unsigned long long res = 0;
    unsigned long long a = 1;
    for (int i = 0; i < 64; i++) {
        res = res + arr[i] * a;
        a = a * 2;
    }
    printf("xeu = %llu\n", res);
    printf("xeh = %llx\n", res);
    return 0;
}

```

### km03-5

В аргументах командной строки задаётся начальная точка `x0` - вещественное число, количество шагов `n` (целое число от 1 до 100000) и шаг `dx` - вещественное число.

Программа должна создать два процесса сына, каждый из которых должен создать одного своего процесса-сына (внука основного процесса). Внук от первого сына отправляет внуку от второго сына значения `sin(x)` для всех точек `x0`, `x0 + dx`, ..., `x0 + n * dx` (всего n + 1 число), а внук от второго сына отправляет первому внуку значения `cos(x)` для всех этих точек. Внук от первого сына вычисляет сумму квадратов полученных чисел, а внук от второго сына - сумму модулей. Каждый из внуков выводит свой номер (1 или 2) и вычисленное число на стандартный поток вывода. Результат вычислений выводите не менее чем с 10 знаками мантиссы.

Отец дожидается завершения работы всех созданных процессов и выводит на стандартный поток вывода два нуля.

***Решение:***

```c
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>
#include <math.h>
#include <stdlib.h>

int main (int argc, char **argv)
{
    double x;
    sscanf(argv[1], "%lf", &x);
    int n;
    sscanf(argv[2], "%d", &n);
    double dx;
    sscanf(argv[3], "%lf", &dx);
    int fd12[2];
    int fd21[2];
    pipe(fd12);
    pipe(fd21);
    double sq_sum;
    double abs_sum;

    if (!fork()) {
        if (fork() == 0) {
            close(fd12[0]);
            close(fd21[1]);
            double tmp, tmp1;
            for (int i = 0; i < n; i++) {
                tmp1 = sin(x + i * dx);
                write(fd12[1], &tmp1, sizeof(double));
                read(fd21[0], &tmp, sizeof(double));
                sq_sum = sq_sum + (tmp * tmp);
            }
            printf("1: %.11g\n", sq_sum); //не знаю как написать мантиссу
            close(fd12[1]);
            close(fd21[0]);
            exit(0);
        }
        wait(NULL);
        close(fd12[0]);
        close(fd21[1]);
        close(fd12[1]);
        close(fd21[0]);
        exit(0);
    }

    if (!fork()) {
        if (fork() == 0) {
            close(fd12[1]);
            close(fd21[0]);
            double tmp, tmp1;
            for (int i = 0; i < n; i++) {
                tmp1 = cos(x + i * dx);
                write(fd21[1], &tmp1, sizeof(double));
                read(fd12[0], &tmp, sizeof(double));
                abs_sum = abs_sum + fabs(tmp);
            }
        printf("2: %.11g\n", abs_sum);
        close(fd12[0]);
        close(fd21[1]);
        exit(0);
        }
        close(fd12[0]);
        close(fd21[1]);
        close(fd12[1]);
        close(fd21[0]);
        wait(NULL);
        exit(0);
    }
    close(fd12[0]);
    close(fd21[1]);
    close(fd12[1]);
    close(fd21[0]);
    wait(NULL);
    wait(NULL);
    printf("00\n");
}
```

## 2021

### km01-1

На стандартном потоке ввода подаются 64-битные беззнаковые числа в шестнадцетеричной записи. На стандартный поток вывода напечатайте 64 числа в десятичной записи, каждое из который равно количеству чисел во входных данных у которых на соответсвующей позиции бит установлен. Первое число в выводе - это количество чисел во входных данных, у которых установлен бит 0 (младший бит), а последнее число в выводе - это количество чисел во входных данных, у которых установлен бит 63 (старший бит).

### km01-2

В аргументе командной строки задается имя бинарного регулярного файла. Бинарный файл содержит 128-битные беззнаковые числа, записанные в порядке Big-Endian (то есть старший байт числа в памяти хранится по меньшему адресу). Отсортируйте числа в порядке возрастания и запишите результат в этот же файл. Размер файла кратен 16 байтам. В файле может находиться не более 2097152 чисел. Глобальные (`static`) переменные использовать запрещено. Памяти достаточно для чтения всего файла в память.

### km01-3

В аргументах командной строки задается 64-битное беззнаковое число `M`, имя программы для запуска `PROG`. Ваша программа должна запустить `PROG`, передав ей на стандартный поток ввода последовательности чисел `0, 1, 4, 9, 16, ... (M - 1)^2` (то есть последовательность квадратов чисел от `0` до `M - 1` в десятичном виде, числа разделяются пробельными символами). Программа должна считать последовательность 64-битных беззнаковых чисел, которые программа `PROG` выводит на стандартный поток вывода, и на стандартный поток вывода напечатать их сумму. Для взаимодействия вашей программы и программы `PROG` используйте неименованные каналы. Программу `PROG` запускайте с помощью `execlp`. Процесс-родитель должен завершиться после всех созданных им процессов с кодом завершения `0`.

### km01-1

**Обработка списка**

Дано определение типа звена двусвязного списка строк:

```
struct Node
{
    struct Node *prev, *next;
    char *elem;
};
```

И определение типа списка

```
struct List
{
    struct Node *first, *last;
};
```

Напишите функцию process, обрабатывающую список за один проход от первого до последнего элемента по нему следующим образом:

```
void process(struct List *pl, const char *str);
```

Звенья, у которых строка elem равна строке str удаляются, а звенья, у которых строка elem лексикографически больше строки str переставляются в конец списка. Прочие звенья не изменяются.

При удалении звена необходимо освобождать память, занимаемую звеном и строкой. В списке нет заглавного звена, и он не закольцован. Поле `elem`, параметры `pl` и `str` никогда не равны `NULL`.

На проверку сдается только функция process и необходимые для нее директивы `#include`.

### km01-2

**Виртуальная память**

Рассмотрим модельный 16-битный процессор с 16-битным виртуальным и физическим адресным пространством, адресуемым побайтно, в котором реализована одноуровневая виртуальная страничная адресация с размером страницы 512 байт. Процессор хранит целые числа в формате Little-Endian.

Первым аргументом командной строки передается бинарный файл размером 64KiB - содержимое физической памяти. Вторым аргументом командной строки передается физический адрес начала таблицы страниц в шестнадцатеричном виде.

Таблица страниц размещается в физической памяти, начиная с указанного адреса. Каждая запись таблицы страниц имеет размер 16 бит, в которой старшие биты хранят номер физической страницы, а младшие биты равны 0.

На стандартном потоке ввода задаются выровненные виртуальные адреса 16-битных ячеек памяти в шестнадцатеричной записи. На стандартный поток вывода напечатайте значения, хранящиеся в ячейках. Значения выводите в беззнаковом десятичном виде.

### km01-3

**Условный запуск программ**

Программе в аргументах командной строки передаются три команды для выполнения. Программа должна запустить на выполнение процессы, чтобы они выполнялись в конфигурации, соответствующей команде shell:

```
{ cmd1 || cmd2 } && cmd3
```

Родительский процесс должен дождаться завершения всех созданных им процессов и сам завершить выполнение с кодом возврата `0` или `1` в зависимости от успешности выполнения процессов.

Команды `cmd1`, `cmd2`, `cmd3` можно запускать на выполнение с помощью `execlp`.

Запись `a || b` означает то же самое, что `!a?b:true`. Запись `a && b` означает то же самое, что `a?b:false`. Скобки `{` и `}` используются для группировки.

Для шелла процесс считается завершившимся успешно, если процесс завершился с помощью системного вызова exit (макрос `WIFEXITED` возвращает истинное значение), и код завершения процесса (макрос `WEXITSTATUS`) равен `0`. В других случаях процесс считается завершившимся неуспешно.

Соответственно, ваша программа должна завершиться с кодом `0` в случае успешного выполнения заданной группы процессов и с кодом `1` в случае неуспешного их выполнения.

Организуйте вашу программу таким образом, чтобы избежать дублирование кода. В частности, запуск процесса и проверка статуса его завершения может быть вынесена в функцию.

 **Примечания по тестированию вашей программы:** . Тестирование завершается с вердиктом `'Synchronization error'`, если процесс-отец (то есть ваша программа, запускаемая на тестирование) заканчивает работу раньше какого-либо из своих потомков.

***Решение:** (Хорошо работает, прошло все тесты. Только нужно вынести похожие куски кода в функцию, чтобы не было дублирования кода)*

```c
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int 
main(int argc, char** argv) {
    int status;

    if (!fork()) {
        if (!fork()) {
            execlp(argv[1], argv[1], NULL);
            return 127;
        }
        wait(&status);
        if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
            return 0;
        }
  
        if (!fork()) {
            execlp(argv[2], argv[2], NULL);
            return 127;
        }
        wait(&status);
        if (WIFEXITED(status)) {
            return WEXITSTATUS(status);
        }

        return WTERMSIG(status);
    }
    wait(&status);

    if ((WIFEXITED(status) && WEXITSTATUS(status) != 0) || WIFSIGNALED(status)) {
        return 1;
    }
  
    if (!fork()) {
        execlp(argv[3], argv[3], NULL);
        return 127;
    }
    wait(&status);

    if ((WIFEXITED(status) && WEXITSTATUS(status) != 0) || WIFSIGNALED(status)) {
        return 1;
    }

    return 0;
}
```

### km01-4

**Конвейер**

Программе в аргументах командной строки передаются три команды для выполнения, затем два имени файла (всего 5 аргументов командной строки). Программа должна запустить на выполнение процессы, чтобы они выполнялись в конфигурации, соответствующей команде `shell`:

```
( cmd1 < file1 && cmd2 ) | cmd3 >> file2
```

Родительский процесс должен дождаться завершения всех созданных им процессов и сам завершить выполнение.

Считайте, что команды `cmd1`, `cmd2`, `cmd3` можно запускать на выполнение с помощью execlp.

Запись `CMD1 && CMD2` означает, что процесс `CMD2` должен быть запущен только после успешного завершения процесса `CMD1`.

Запись ( `CMD` ) используется для группировки, при этом вся командная строка `CMD` выполняется в отдельном процессе, порожденном основным процессом.

***Решение:***

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/types.h>

// ( cmd1 < file1 && cmd2 ) | cmd3 >> file2
// cmd1  пишет в fd[1], а cmd3 еще не читает. Возможно переполнение
// wait
// cmd2  cmd3


int main(int argc, char **argv) {
    int status;
    int in, out;
    int fd[2];
    pipe(fd);
    if (fork() == 0) { // son1  !!!
        close(fd[0]);
        if (fork() == 0) { // gson1
            in = open(argv[4], O_RDONLY);
            dup2(in, 0);
            close(in);
            dup2(fd[1], 1);
            close(fd[1]);
            execlp(argv[1], argv[1], NULL);
            exit(127);
        }

        wait(&status);
        if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
           if (fork()==0) { // gson2
               dup2(fd[1], 1);
               close(fd[1]);
               execlp(argv[2], argv[2], NULL);
               exit(127);
           }
        }
        close(fd[1]);  // проверять !!!
       while (wait(NULL) > 0) {;}
       exit(0);
    }
    close(fd[1]);// особое внимание
    if (fork()==0) {  // son2
        dup2(fd[0], 0);
        close(fd[0]);
        out = open(argv[5], O_WRONLY | O_APPEND | O_CREAT, 0666);
        dup2(out, 1);
        close(out);
        execlp(argv[3], argv[3], NULL);
        exit(127);
    }
    close(fd[0]);
    while (wait(NULL) > 0) {;}
    return 0;
}
```

### km01-5

**Сигналы**

Программе на стандартном потоке ввода задаются два целых числа `low` и `high`. Программа должна вывести на стандартный поток вывода свой `PID`, после вывода программа должна обрабатывать получение сигналов `SIGINT` и `SIGTERM`.

Программа должна вычислять простые числа в интервале `[low,high)`. Если программа получила сигнал `SIGINT`, программа должна вывести на стандартный поток вывода последнее на текущей момент найденное простое число. При получении `SIGINT` в четвертый раз, программа должна закончить работу с кодом завершения `0`. Таким образом, может быть выведено не более трех простых чисел.

При получении сигнала `SIGTERM` программа должна завершиться с кодом `0`.

Если программа закончила вычисления, программа должна вывести на стандартный поток вывода число `-1` и завершиться с кодом `0`.

Если на момент прихода сигнала ни одно простое число найдено не было, выводите `0`.

Учтите, что стандартный поток вывода программы будет перенаправлен в `pipe`.

***Решение:***

```c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <signal.h>

int simple_num = 0;
int count = 1;

void
SigHndlr1(int s) {
    if (count == 4) {
        _exit(0);
    }
    printf("%d\n", simple_num);
    count++;
    signal(SIGINT, SigHndlr1); // возобновляю обработчик сигнала
}

void
SigHndlr2(int s) {
    _exit(0);
}

int
main(void) {
    int i, j;
    int low, high;
    scanf("%d%d", &low, &high);
    printf("%d\n", getpid());

    signal(SIGINT, SigHndlr1);
    signal(SIGTERM, SigHndlr2);

    for (i = low; i < high; i++) {
        int flag = 0;
        for (j = 2; j < i; j++) {
            if (i % j == 0) {
                flag = 1;
                break;
            }
        }
        if (flag == 0) {
            simple_num = i;
        }
    }

    printf("-1\n");
    return 0;
}
```

### km02-1

Дано определение элемента списка и самого списка:

```c
struct ListItem {
    struct ListItem *prev, *next;
    uint64_t value;
};
```

```c
struct List {
    struct ListItem *first, *last;
};
```

Напишите функцию

```c
struct ListItem *to_front(struct List *lst, uint64_t value, size_t maxsize);
```

Параметр `lst` не равен `NULL`, `maxsize` больше нуля.

Функция ищет в списке `lst` первый по порядку элемент со значением `value`. Если элемент найден, то соответсвующий элемент списка переставляется в его начало. Если элемент не найдет и длина списка меньше `maxsize`, то создаётся новый элемент и вставляет в начало списка. Если элемент не найден и длина списка не меньше `maxsize`, то из списка удаляется один последний элемент, а новый элемент со значением `value` вставляется в его начало.

Функция возвращает найденный или созданный элемент.

Например, для списка `{1, 2, 3, 4}` и значения для поиска `3` в результате работы функции должен получиться список `{3, 1, 2, 4}`, то есть элемент со значением `3` должен быть переставлен в списке с третьей позиции на первую.

Для списка `{1, 2, 3, 4}`, значения для поиска `5` и ограничения на размер `5` в результате работы функции должен получиться список `{5, 1, 2, 3, 4}`.

Для списка `{1, 2, 3, 4}`, значения для поиска `5` и ограничения на размер `3` в результате работы функции должен получиться список `{5, 1, 2, 3}`.

### km02-3

В аргументах командной строки программе передаются три ключа очередей сообщений SystemV IPC, обозначаемых как `IN1`, `IN2`  и `OUT`. Ваша программа должна считывать знаковые 64-битные числа из очередей `IN1`  и `IN2`. Признаком конца ввода является любое число с типом соощения `100`. В выходную очередь `OUT` должна быть записана последовательность знаковых 64-битных чисел, которая является результатом слияния в порядке неубывания входных последовательностей.

Все числа в выходной очереди сообщений должны иметь тип `1`. Для обозначения конца входной последовательности используйте сообщение с типом `100`, содержащее число `0`.

### km04-1

В аргументах командной строки задаются две команды для запуска (`PROG1` и `PROG2`) и имя текстового файла (`FILE`). Текстовый файл содержит последовательность беззнаковых 64-битных целых чисел в десятичной записи, завершающуюся признаком конца файла. Числа в последовательности разделяются пробельными символами.

Программа запускает два процесса `PROG1` и `PROG2` и отправляет им числа из файла `FILE` так, что первое число отправляется первому процессу, а второе число - второму процессу, третье число - снова первому процессу и т. д.

Для каждого отправленного числа программа ожидает результата обработки данного числа соответствующим процессом, который тоже является 64-битным беззнаковым целым числом в десятичной записи.

После завершения программы в файле с именем `FILE` должна находиться преобразованная последовательность, то есть вместо каждого исходного числа должно быть записано число-результат обработки данного числа соответсвующим процессом.

Для передачи чисел между процессами должен использоваться только один неименованный канал, и синхронизация должна выполняться с помощью сигналов: сигнал `SIGUSR1` отправляется запущенному процессу-сынку в случае, когда готово очередное число для обработки, а сигнал `SIGTERM` - когда числа закончились. Процессы-сыновья отправляют родителю сигнал `SIGUSR1`, когда готов результат обработки.

Процессы-сыновья считывают данные со стандартного потока ввода и выводят результат на стандартный поток вывода.

Когда запущенный процесс-сын завершил свою инициализацию, он записывает в канал свой `pid` в текстовом виде. Процесс-родитель должен начать обработку файла только после того, как получит идентификаторы процессов от обеих сыновей.

Для запуска программ на выполнение использовать `exelp`. Процесс-родитель должен завершиться после завершения своих детей.

*Пример входных данных:*

```txt
1 2 3 4 5
6 7
8 9
10
```

Если программа `PROG1` прибавляет к каждому полученному ей числу значение 100, а программа `PROG2` прибавляет к каждому полученному ей числу значение 200, то в файле должен получиться следующий результат:

```txt
101
202
103
204
105
206
107
208
109
210
```

## 2022

Задачи с пересдачи 11.02.2022

### km02-1

Программа должна создать следующие процессы: процесс-родитель создаёт два сына (`P1` и `P2`), сын `P1` создаёт своего сына (`P3`), а сын `P2` создаёт своего сына (`P4`). Процессы `P3` и `P4` должны быть связаны неименованным каналом в направлении от `P4` к `P3`. Процесс `P4` должен считывать каждую вторую строку текста в файле, начиная с первой, имя которого задаётся в командной строке, и переслать её в канал. Процесс `P3` должен считывать строки из канала, выводить первый и последний символ строки и символ перехода на новую строку. Система процессов должна завершиться, когда весь выходной файл будет обработан. Процесс-родитель должен завершиться последним.

Под строкой текста в файле понимается последовательность символов, заканчивающаяся символом `'\n'`. Строка текста может содержать любые символы, кроме `'\0'` и `'\n'` в середине строки.

Например, если программа запущена с аргументом:

```c
./solution input.txt
```

и файл `input.txt` содержит текст:

```txt
1abc
2def
3ghi
```

То на стандартный поток вывода должно быть напечатано:

```txt
1a
3i
```

***Решение:***

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[])
{
    int fd[2] = {0};
    if (pipe(fd) == -1) {
        return 1; // ?
    }
    FILE *input = fopen(argv[1], "r");
    if (!input) {
        _exit(1);
    }
    fseek(input, 0, SEEK_END);
    int size = ftell(input);
    fseek(input, 0, SEEK_SET);
    FILE *read_fd = fdopen(fd[0], "r");
    FILE *write_fd = fdopen(fd[1], "w");
    int pid_p1 = fork();
    if (!pid_p1) {
        fclose(write_fd);
        int pid_p3 = fork();
        if (!pid_p3) {
            char *str1 = calloc(size + 1, sizeof(*str1));
            while (fgets(str1, size + 1, read_fd)) { // ?
                if (str1[0] != '\n') {
                    printf("%c", str1[0]);
                    if (str1[1] != '\n') {
                        printf("%c", str1[strlen(str1) - 2]);
                    } else {
                        printf("%c", str1[0]);
                    }
                }
                printf("\n");
                for (int i = 0; i < size + 1; ++i) {
                    str1[i] = 0;
                }
            }
            fclose(read_fd);
            fclose(input);
            free(str1);
            _exit(0);
        }
        fclose(input);
        fclose(read_fd);
        waitpid(pid_p3, NULL, 0);
        _exit(0);
    }
    int pid_p2 = fork();
    if (!pid_p2) {
        fclose(read_fd);
        int pid_p4 = fork();
        if (!pid_p4) {
            char *str2 = calloc(size + 1, sizeof(*str2));
            if (!str2) {
                fclose(write_fd);
                fclose(input);
                _exit(1);
            }
            while (fgets(str2, size + 1, input)) {
                fprintf(write_fd, "%s", str2);
                fflush(write_fd);
                fgets(str2, size + 1, input);
                for (int i = 0; i < size + 1; ++i) {
                    str2[i] = 0;
                }
            }
            free(str2);
            fclose(input);
            fclose(write_fd);
            _exit(0);
        }
        fclose(write_fd);
        fclose(input);
        waitpid(pid_p4, NULL, 0);
        _exit(0);
    }
    fclose(write_fd);
    fclose(input);
    fclose(read_fd);
    waitpid(pid_p1, NULL, 0); // ?
    waitpid(pid_p2, NULL, 0); // ?
    return 0;
}
```

### km02-2

Программа должна создать три процесса: обозначим их процессы 1, 2, 3. Процесс 1 считывает 32-битные беззнаковые целые числа из файла, имя которого задаётся в командной строке, до признака конца файла. Каждое нечётное по порядковому номеру число (то есть 1, 3, 5 число в файле) передаётся процессу 2, а каждое чётное по порядковому номеру число (то есть 2, 4, 6 число в файле) передаётся процессу 3. Процесс 2 прибавляет к числу 1 и выводит его на стандартный поток вывода. Процесс 3 умножает число на 2 и выводит его на стандартный поток вывода. Процессы завершаются при исчерпании входного файла. Порядок следования чисел на стандартном потоке вывода должен совпадать с порядком чисел во входном файле. Арифметические операции проводятс я над 32-битными беззнаковыми числами по правилам языка Си. Процесс родитель должен дождаться завершения процессов-зыновей и зывершиться сам последним.

Для передачи данных и синхронизации использовать семафоры и разделяемую память.

Например, если программа запущена с аргументом:

```txt
./solution input.txt
```

И файл `input.txt` содержит текст:

```txt
2
4
6
8
9
```

На стандартный поток вывода должно быть напечатано:

```txt
3
8
7
16
10
```

***Решение:***

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <wait.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <fcntl.h>

int main(int argc, char **argv)
{
  int k = ftok(argv[0],0);
  int semid = semget(k, 3, 0666| IPC_CREAT| IPC_EXCL);
  int shmid = shmget(k, 2*sizeof(unsigned), 0666|IPC_CREAT| IPC_EXCL);
  unsigned *p = shmat(shmid, NULL, 0);
  p[1] = 0;
  semctl ( semid, 0, SETVAL, 1);
  semctl ( semid, 1, SETVAL, 0);
  semctl ( semid, 2, SETVAL, 0);
  unsigned u;
  if (fork() == 0) {
     FILE *f = fopen(argv[1], "r");
     unsigned odd = 1;
     while (fscanf(f, "%u", &u)>0) {
        struct sembuf dn = {0, -1, 0};
        semop(semid, &dn, 1);
        *p = u;
        if (odd) {
           struct sembuf up = {1, 1, 0};
           semop(semid, &up, 1);
        }
        else {
           struct sembuf up = {2, 1, 0};
           semop(semid, &up, 1);
        }
        odd ^= 1;
     }
     p[1] = 1;
     fclose (f);
     struct sembuf up[] = {{1, 1, 0},{2, 1, 0}};
     semop(semid, up, 2);
     shmdt(p); // не обязательно, но культурнее
     exit(0);   
  }

  for (int i = 1; i <= 2; i++) {
     if (fork() == 0) {
           while (1) {
              struct sembuf dn = {i, -1, 0};
              semop(semid, &dn, 1);
              if (p[1]) {
                 break;
              }
             if (i == 2) {
               *p *= 2;
              } else {
               *p += 1;
              }
              printf("%u\n", *p);
              fflush(stdout);
              struct sembuf up = {0, 1, 0};
              semop(semid, &up, 1);     
           }
       }   
        shmdt(p); // не обязательно, но культурнее
        exit (0);
     }
  
  }
  while (wait(NULL) > 0 );
  shmdt(p); // обязательно!
  semctl(semid, IPC_RMID, 0);
  shmctl(shmid, IPC_RMID, NULL);
  return 0;
}

```

# Другие задачи

## Задачи с зачёта (декабрь 2021)

### 1

Вам дан тип узла двунаправленного закольцованного списка, который хранит Си-строку. Каждый элемент списка содержит адрес свой отдельно обрасти памяти под Си-строку.

```c
struct list_item {
    char *str;
    struct list_item *next, *prev;  
}
```

Напишите функцию

```c
void process (struct list_item **list, const char *s);
```

Она получает на вход указатель на начало двунаправленного закольцованного списка `list` и Си-строку `s`. Функция находит элементы списка, чья строка содержит строку `s` в качестве подстроки, и полностью дублирует этот элемент столько раз, какова длина этой строки. Остальные элементы надо переставить в конец списка с сохранением порядка. Функция должна один раз пройти по списку и не использовать функцию освобождения памяти.

При компиляции флагами из `ejudge` не должно быть функции `main` и объявления типа `struct_item`, т.к. они будут подставлены в `ejudge` при проверке. Для тестирования программы вы можете написать свою функцию `main` в отдельном модуле или воспользоваться условной компиляцией. Все необходимые `#include` должны присутствовать в вашем исходнике.

Пример: если функция получит список: `["a", "xabc", "ab"]` и строку `"abc"`, то список должен стать `["xabc", "xabc", "xabc", "xabc", "xabc", "a", "ab"]`

***Решение*:**

```c
void
process(struct list_item **list, const char *s) {
    struct list_item *ptr = *list;
    struct list_item *last = ptr->prev;
    do {
        struct list_item *nextptr = ptr->next;
        if (strstr(ptr->str, s)) {
            for (int i = 0; i < strlen(ptr->str); i++) {
		struct list_item *new = malloc(sizeof(struct list_item));
                new->str = malloc(strlen(ptr->str) + 1);
                strcpy(new->str, ptr->str);
  
                new->next = ptr->next;
                new->prev = ptr;
                ptr->next = new;
                new->next->prev = new;
            }

            if (ptr == last) {
                last = nextptr->prev;
            }
        } else {
            if (ptr == (*list)) {
                (*list) = (*list)->next;
            } else {
                if (ptr == last) {
                    last = last->prev;
                }
                ptr->prev->next = ptr->next;
                ptr->next->prev = ptr->prev;
                ptr->next = (*list);
                ptr->prev = (*list)->prev;
                (*list)->prev->next = ptr;
                (*list)->prev = ptr;
            }
        }
        ptr = nextptr;

    } while (ptr != last->next);
}
```

### 2

Программа получает на стандартный ввод последовательность строк, каждая строка - это последовательность команд, разделенных точкой с запятой. За последней строкой может не идти перенос строки. Нужно выполнить последовательно все эти команды. Внутри команды точка с запятой не встречается. Команда состоит из последовательности слов - имени программы и её аргументов. "Пустых" команд не может быть (т.е. в строке не может быть в конце и в начале точки с запятой и двух точек с запятой подряд). Программу запускать с использованием переменной `PATH`. Код завершения программы равен коду завершения последней запущенной команды, если она завершилась системным вызовом `_exit`, а иначе `128 + номер сигнала`. Если функция `exec` завершилась ошибкой, процесс завершается с кодом `127`. В случае других ошибок - код завершения `1`. Использовать `bash` напрямую или косвенно запрещается. Все аргументы разделены не менее чем одним пробельным символом. Длина строки ограничена лишь размерами памяти.

Пример ввода:

```
echo 1 ; echo 2
echo 3 4a
```

Ответ:

```
1
2
3 4a
```

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <ctype.h>
#include <unistd.h>

char ***arg = NULL;
int argc = 0;

void
delete(void)
{
    for (int i = 0; i < argc; i++) {
        int j = 0;
        while (arg[i][j] != NULL) {
            free(arg[i][j]);
            j++;
        }
        free(arg[i]);
    }
    free(arg);
}

int
main(void)
{
    int c;
    while ((c = getchar())!= EOF) {
        argc++;
        arg = realloc(arg, argc * sizeof(char **));
        arg[argc - 1] = NULL;
        while (c != EOF && isspace(c)) {
            c = getchar();
        }
        int size = 0, num_arg = 0;
        while (c != EOF && c != ';' && c != '\n') {
            if (num_arg == size) {
                if (size == 0) {
                    size = 1;
                } else {
                    size = size * 2;
                }
                arg[argc - 1] = realloc(arg[argc - 1], size * sizeof (char *));
            }
            arg[argc - 1][num_arg] = NULL;
            int size_word = 0, num_sym_in_word = 0;
            while (c != EOF && !isspace(c) && c != ';') {
                if (num_sym_in_word == size_word) {
                    if (size_word == 0) {
                        size_word = 1;
                    } else {
                        size_word = size_word * 2;
                    }
                    arg[argc - 1][num_arg] = realloc(arg[argc - 1][num_arg], size_word * sizeof(char));
                }
                arg[argc - 1][num_arg][num_sym_in_word] = c;
                num_sym_in_word++;
                c = getchar();
            }
            if (num_sym_in_word == size_word) {
                if (size_word == 0) {
                    size_word = 1;
                } else {
                    size_word = size_word * 2;
                }
                arg[argc - 1][num_arg] = realloc(arg[argc - 1][num_arg], size_word * sizeof(char));
            }
            arg[argc - 1][num_arg][num_sym_in_word] = '\0';
            num_arg++;
            while (c != EOF && isspace(c) && c != '\n') {
                c = getchar();
            }
        }
        if (num_arg == size) {
            if (size == 0) {
                    size = 1;
               } else {
                    size = size * 2;
               }
            arg[argc - 1] = realloc(arg[argc - 1], size * sizeof(char *));
        }
        arg[argc - 1][num_arg] = NULL;
    }
    atexit(delete); // указанная функция будет вызвана при exit
    int status;
    pid_t pid;
    for (int i = 0; i < argc; i++) {
        if ((pid = fork()) == 0) {
            execvp(arg[i][0], arg[i]);
            exit(127);
        } else if (pid == -1) {
            exit(1);
        }
        wait(&status);
    }
    if (WIFEXITED(status)) {
        exit(WIFEXITED(status));
    }
    if (WIFSIGNALED(status)) {
        exit(128 + WTERMSIG(status));
    }
}
```

### 3

Аргументы командной строки вашей программы такие: `p1 arg11 arg12 ... arg1N -- p2 arg22 ... arg2M`. Отец создаёт дочерний процесс и соединяется с ним ровно одним каналом. Отец читает последовательность неотрицательных целых чисел со стандартного ввода. Если он читает `0`, то отправляет сыну сигнал (выберите сами, какой), а если больше `0`, то спит указанное количество микросекунд (функция `usleep`). Сын на каждый третий приход сигнала выполняет команду `p1 arg11 arg12 ... arg1N | p2 arg21 arg22 ... arg2M`, используя `PATH`. Первый пришедший сигнал имеет номер `1`, т.е. первый раз сын должен запустить команду, получив сигнал в третий раз. Команды не должны пересекаться по времени. То есть их надо выполнять последовательно нужное количество раз. Активное ожидание недопустимо. Считать, что последовательность чисел не содержит двух нулей подряд и не оканчивается нулём. Отец завершает сына отправкой сигнала `SIGTERM`, сын должен выполнить все требуемые команды и завершиться.

***Решение:***

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/wait.h>
#include <unistd.h>

int flag_execute = 0, flag_end = 0;

void
signal_handler(int sig)
{
    if (sig == SIGUSR1) {
        static int counter = 0;
        counter++;
        if (counter == 3) {
            flag_execute++;
            counter = 0;
        }
    }
    if (sig == SIGTERM) {
        flag_end = 1;
    }
}

int
main(int argc, char **argv)
{
    int p2;
    for (p2 = 1; p2 < argc; p2++) {
        if (strcmp(argv[p2], "--") == 0) {
            break;
        }
    }
    argv[p2] = NULL;
    p2++;
    int fd[2];
    if (pipe(fd) < 0) {
        return 1;
    }
    signal(SIGUSR1, signal_handler);
    signal(SIGTERM, signal_handler);
    pid_t pid;
    if ((pid = fork()) == 0) {
        while (1) {
            while (!flag_execute && !flag_end) {
                usleep(100);
            }
            if (flag_end && !flag_execute) {
                break;
            }
            if (fork() == 0) {
                dup2(fd[1], 1);
                close(fd[0]);
                close(fd[1]);
                execvp(argv[1], argv + 1);
                exit(127);
            }
            if (fork() == 0) {
                dup2(fd[0], 0);
                close(fd[0]);
                close(fd[1]);
                execvp(argv[p2], argv + p2);
                exit(127);
            }
            close(fd[0]);
            close(fd[1]);
            wait(NULL);
            wait(NULL);
            flag_execute--;
        }
        exit(0);
    }
    signal(SIGUSR1, SIG_DFL);
    signal(SIGTERM, SIG_DFL);
    int num;
    while (scanf("%d", &num) == 1) {
        if (num == 0) {
            kill(pid, SIGUSR1);
        } else {
            usleep(num);
        }
    }
    kill(pid, SIGTERM);
    wait(NULL);
}
```

### 4

Отец получает на стандартный ввод целые неотрицательные числа `N` и `K`. Отец создаёт временный файл и записывает туда число `K`. Затем он запускает параллельно `N` дочерних процессов. Дочерние процессы по очереди по кругу дописывают в конец файла число, на единицу меньшее, чем последнее число в файле. Как только они дошли до `0`, дочерние процессы завершаются. Отец дожидается завершения дочерних процессов, распечатывает последовательно содержимое файла на стандартный вывод и удаляет файл. Глобальными переменными пользоваться нельзя. Синхронизацию процессов осуществить при помощи `IPC`. Число `K` детям иным образом, кроме как в файле, не передавать.

***Решение:***

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/sem.h>
#include <sys/ipc.h>
#include <ctype.h>

int
main (void) {
    int i;
    unsigned int N, K;
    scanf("%u %u", &N, &K);
    char filename[10] = "tmpXXXXXX";
    int tmp_fd = mkstemp(filename);
    write(tmp_fd, &K, sizeof(K));

    union semun {
        int     val;            /* value for SETVAL */
        struct  semid_ds *buf;  /* buffer for IPC_STAT & IPC_SET */
        u_short *array;         /* array for GETALL & SETALL */
     };

    int semid = semget(IPC_PRIVATE, N, IPC_CREAT | 0666);
    u_short *arr = malloc(N*sizeof(u_short));
    arr[0] = 1;
    for (i = 1; i < N; i++) {
        arr[i] = 0;
    }
    semctl(semid, 0, SETALL, (union semun) {.array = arr});
    free(arr);

    for (i = 0; i < N; i++) {
        if (fork() == 0) {
            while (1) {
                unsigned int num;
                semop(semid, &(struct sembuf) {i, -1, 1}, 1);
                lseek(tmp_fd, -sizeof(unsigned int), SEEK_END);
                read(tmp_fd, &num, sizeof(num));
                if (num == 0) {
                    semop(semid, &(struct sembuf) {(i + 1) % N, +1, 0 }, 1);
                    return 0;
                }
                num--;
                write(tmp_fd, &num, sizeof(num));
                semop(semid, &(struct sembuf) {(i + 1) % N, +1, 0 }, 1);
                if (num == 0) {
                    return 0;
                }
            }
        }
    }
    while (wait(NULL) > 0) {;}

    lseek(tmp_fd, 0, SEEK_SET);
    unsigned int val;
    while (read(tmp_fd, &val, sizeof(val)) > 0) {
        printf("%u\n", val);
    }

    unlink(filename);
    return 0;
}
```

## Задачи из контеста Внедрение от Машечкина

### pr03-2

**Создание процессов**

На стандартном потоке ввода задается целое число `N` (`N` > 0). Требуется создать `N - 1` процессов так, чтобы первый процесс (процесс-родитель) вывел на стандартный поток вывода число `1`, второй процесс (его сын) вывел на стандартный поток вывода число `2`, третий процесс (сын сына) вывел `3` и так далее.

Вывод должен быть таким, чтобы всегда на стандартном потоке вывода оказывалась последовательность `1 2 3 ... N`, записанная в одну строку строго с одним пробелом между числами. В конце вывода должен находиться символ `\n`. Дополнительные пробелы в начале или конце строки не допускаются. Для вывода использовать средства высокого уровня.

Процесс-родитель должен завершаться самым последним из всех процессов.

Не используйте рекурсию!

***Решение:***

```c
#include <sys/types.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int
main(void)
{
    int N;
    scanf("%d", &N);
    int i;
    for (i = 1; i <= N; i++) {
        printf("%d", i);
        fflush(stdout);
        if (i < N) {
            printf(" ");
            fflush(stdout);
            if (fork()) {
                break;
            }
        } else {
            break;
        }
    }
    wait(NULL);
    if (i == 1) {
        printf("\n");
    }
}

```

### pr01-5

**Слияние файлов**

В аргументах командной строки задаются имена текстовых файлов, содержащих последовательности целых чисел в порядке неубывания.

На стандартный поток вывода напечатайте последовательность, составленную из всех чисел во входных последовательностях в порядке их неубывания.

Не используйте сортировку.

Не забывайте завершать вывод программы символом `\n`.

Каждый файл может быть открыт и прочитан не более одного раза.
