# Все задачи комиссий по практикуму

## 2015 - 2016

### K1-15-16-1

Описан тип звена списка

```c
struct Node { 
     struct Node *next;
     char *elem; 
};
```

Написать функцию

```c
struct Node *delete_all(struct Node *list, const char *str);
```

удаляющую из списка все звенья, содержащие указатели на строки, равные строке `str`, и освобождающую память, занимаемую этими звеньями и соответствующими строками.
Функция принимает указатель на начальное звено в списке и возвращает указатель на начальное звено после удаления. В списке нет заглавного звена. Поле `elem` в списке и параметр `str` никогда не равны `NULL`.

На проверку сдаётся только функция `delete_all` и необходимые для неё директивы `#include`. Определение структуры `Node` и функция `main` из сдаваемого на проверку файла должны быть удалены или закомментированы.

### K1-15-16-2

Программа должна обработать бинарный файл "`input.dat`", расположенный в текущем каталоге и содержащий 32-битные знаковые целые числа. Переставить в данном бинарном файле числа таким образом, чтобы сначала шли все отрицательные числа, а следом шли все неотрицательные числа. Порядок чисел одного знака неважен.
Для работы с файлом необходимо использовать функции низкоуровневого ввода-вывода. В памяти разрешается хранить не более 10 чисел из файла.
Программа должна завершать своё выполнение с кодом возврата 0.

### K1-15-16-3

В аргументах командной строки программе передаются 3 параметра: `CMD1`, `CMD2` и файл `FILE3` (в указанном порядке). Реализуйте конвейер:
`CMD | CMD2 > FILE3`

Файл `FILE3` должен создаваться с правами на чтение и запись только для текущего пользователя. Основной процесс должен дожидаться завершения запущенных им процессов и только после этого завершаться с кодом возврата 0.

### K1-15-16-4

В аргументах командной строки программе передаются 2 параметра `CMD` и `N`. `CMD` - это имя другой программы для запуска, `N` - положительное целое число. Программа должна запустить на выполнение программу `CMD` в отдельное процессе.

Если программа `CMD` после запуска завершилась за `N` секунд, она должна быть завершена принудительно, и на стадартный поток вывода должна быть выдана строка
`Process #id terminated`,
где `#id` - это `PID` процесса.

Если программа `CMD` завершилась менее, чем за `N` секунд с кодом завершения `code`, на стандартный поток вывода должна быть выведена строка
`Process #id exited with code #code`

Если программа `CMD` завершилась менее, чем за `N` секунд из-за получения какого-нибудь сигнала `sig` на стандартный поток вывода должна быть выдана строка
`Process #id signaled by #sig`

В любом случае процесс-родитель должен завершаться сразу после завершения сына. Процесс-родитель должен завершаться с кодом 0.

### com04-1

В аргументах командной строки программе передаются вещественные числа `x1` и `x2` `(x2 > x1)` и целое число `n` `(n > 0)`. Процесс родитель должен создавать два сыновних проуесса `proc1` и `proc2`. Процессы обмениваются данными по следующей схеме.

Процесс `proc1` выводит на стандартный поток вывода цифру `"1"` и значение `x2`, затем отправляет по неименованному каналу процесс `proc2` число `x2`.

Процесс `proc2` выводит цифру `"2"`, затем пробел, затем число `cos(x`). После этого процесс `proc1` выводит на стандартный поток вывода цифру `"1"`, затем пробел, затем число `x2 - dx`, где `dx` - это `(x2 - x1) / n`, на третьей итерации - число `x2 - 2*dx` и так далее.

После вывода числа пересылаются в канал. Последним числом, записываемым в канал процесс `proc1`, должно быть число `x1`.

Родитель должен дождаться завершения работы сыновних процессов и сам завершить работу с кодом завершения 0.

Для синхронизации процессов используйте только неименованные каналы. Вещественные числа вводите с 10 значащими десятичными цифрами. Учтите, что ваша программа будет выполняться с перенаправленным стандартным потоком вывода. В этом случае режим буферизации данных при выводе может отличаться от режима буферизации данным при выводе на терминал.

### com04-2

Дано определение типа звена односвязного списка строк

```c
struct ListNode {
     struct ListNode *next; /* указатель на следующее звено в списке */
     char *elem; /* указатель на C-строку в динамической памяти*/
}
```

Написать функцию

```c
struct ListNode *process_list(struct ListNode *list, const char *str);
```

Если значение элемента списка (поле `elem`) не равно строке `str` без учёта регистра букв, и если значение поля `elem` нескольких подряд идущих элементов списка равны без учёта регистра букв, то от всей серии равных элементов оставляется только один первый элемент, все остальные элементы удаляются. Если значение элемента списка равно `str` без учёта регистра букв, соответсвующий элемент списка переставляется в голову списка.

Например, если параметр `str` равен `"B"`, то список `"B", "A", "A", "C", "B", "A", "A", "D", "B"` должен быть преобразован в `"B", "B", "B", "A", "C", "A", "D"`.

При удалении списка необходимо освобождать память, занимаемую элементов списка, так и хранящейся в нём строкой. Функция принимает указатель на начальное звено в списке и должна возвращать указатель на начальное звено модифицированного списка. В списке нет заглавного звена. Поле `elem` узлов списка и параметр `str` никогда не равны нулевому указателю.

На проверку сдаётся только функция `process` и необходимые для неё директивы `#include`. Определение структуры `ListNode` и функция `main` из сдаваемого на проверку файла должны быть удалены или закомментированы.

### com04-3

Напишите функцию `mant_size` с прототипом

```c
int mant_size(ling long value);
```

Функция должна вычислить размер мантиссы числа, то есть разность между номером самого старшего и нулевого бита в группе младших нулевых бит с номером самого старшего единичного бита числа. Например, размер мантиссы числа `1101000` равен `4`, размер мантиссы числа `100` равен `1`. Размер мантиссы числа `0` равен `0`, а размер мантиссы отрицательного числа равен размеру мантиссы соответсвующего положительного числа.

### com04-4

Программе передаются два аргумента командной строки: имя файла для обработки (`FILE`), затем число элементов для обработки (`N`). Файл для обработки - это бинарный файл, содержащий вещественные числа двойной точности. Размер файла всегда кратен размеру одного числа.

Если файл не содержит чисел или содержит только одно число, он не изменяется.

Если файл содержит более одного числа. `i`-е число в файле после обработки вычисляется по формуле `out[i] = 1.5 * in[i] + 0.5 * out[i - 1]`, где `out` - содержимое файла после обработки, а `in` - содержимое файла до обработки.

Число `N` определяет максимальное количество обрабатываемых чисел, то есть если в файле более `N` чисел, то обрабатываются первые `N` чисел, а остальные не изменяются. `in[0]` учитывается в числе `N`.

Таким образом, при `N`  < 1 входной файл вообще не изменяется.

Для работы с файлом необходимо использовать средства низкоуровневого ввода-вывода. Программа должна завершать своё выполнение с кодом возврата 0.

Пример входных данных: `1 2 3 4 5 6 7 8 9`

Результат работы при `N` = 4 : `1 3.5 6.25 9.125 `

## 2017

### com02-1

Звено двусвязного списка определено следующим образом:

```c
struct Elem {
    struct Elem *next, *prev;
    int count;
    char *str;
};
```

Напишите функцию `process` с прототипом:

```c
struct Elem *process(struct Elem *head);
```

Если поле `count` некоторого элемента списка больше `1`, то функция `process` должна сделать `count - 1` копий этого элемента списка и разместить новые элементы непосредственно после исходного элемента. Чтобы различить оригинальный и скопированные элементы к строке в скопированных элементах добавляется `-k`, где `k` изменяется от 2 и до `count`. После создания нужного количества копий элемента списка счётчик `count` устанавливается равным 1.

Гарантируется, что для любого элемента списка поле `count >= 1` и поле `str` не равно `NULL`.

Функция должна возвращать указатель на начало списка.

Пример.
Если на вход функции попадается список 

`{{1, "a"}, {3, "b"}, {1, "c"}}`

Результатом работы должен быть список

`{{1, "a"}, {1, "b"}, {1, "b-2"}, {1, "b-3"}, {1, "c"}}`

### com02-2

В аргументах командной строки задаются:

`N` - число процессов для создания

`FILE1` - текстовый файл, содержащий последовательность 32-битных беззнаковых целых чисел в десятичной записи

`FILE2` - текстовый файл, содержащий последовательность 32-битных беззнаковых целых чисел в шестнадцатеричной записи. Каждое число начинается с начала строки и содержит ровно 8 знаков. Сразу после числа следует символ `\n`. Таким образом, длина каждой строки всегда равна 9.

Основной процесс должен создать `N` процессов, пронумерованных от `0` до `N - 1`. Главный процесс считывает по одному числу из файла `FILE1`. Остаток от деления считанного числа на `N` определяет номер `i` процесса-сына, который должен считать очередной число из файла `FILE2`, выполнить циклических сдвиг влево на `i` разрядов и выполнить побитовое сложение по модулю 2 с накапливаемым в этом процессе результатом. Процесс-сын должен считать только одно число, затем процесс-родитель определит следующего процесса-сына. Начальное значение при побитовом сложении в каждом процессе равно 0.

После чтения всех чисел из файла `FILE1`, процессы по очереди выводят результат вычислений. Результат должен выводиться как 32-битное беззнаковое целое значение в десятичной записи.

Главный процесс дожидается завершения работы всех порождённых процессов, выводит на стандартный поток вывода значение 0 и завершает свою работу.

При циклическом сдвиге влево на один разряд младшие 31 бит сдвигаются на один разря влево, а старший бит исходного числа переходит в младший бит числа результата.

Для синхронизации процессов использовать неименованные каналы.

### com-17-18-01-1

Напишите функцию `bit_reverse` со следующим прототипом:

```c
STYPE bit_reverse(STYPE value);
```

Где `STYPE` - это некоторый целый знаковый тип. Кроме того, определён и тип `UTYPE` - это некоторый целый беззнаковый тип того же размера, что и `STYPE`. Функция меняет порядок бит в числе на противоположный. 

Например, рассмотрим 4-битное целое число `0101`. Поменяв порядок бит на противоположный, получим `1010`. Однако, если то же число рассматривать как 9-битовое, то обратный порядок бит будет равен `10100000`. 

Сдаваемый на проверку текст должен содержать только функцию `bit_reverse`. Определения типов `STYPE` и `UTYPE` и функция `main` в нём находиться не должны.

### com-17-18-01-2

Программе передаются 3 аргументы командной строки:

`count` -  32-битное знаковое неотрицательное число

`modulo` - 32-битное знаковое положительное число

`prog` - имя программы для запуска

Программа (главный процесс `P0`) должна создать сына (процесс `P1`), который должен создать своего сына (процесс `P2`), главный процесс должен создать второго сына (процесс `P3`), который должен создать своего сына (процесс `P4`). 

Процесс `P1` связаывается с процессом `P2` неименованным каналов в направлении от `P1` к `P2`.

Процесс `P2` связаывается с процессом `P4` неименованным каналов в направлении от `P2` к `P4`.

Процесс `P2` запускает с помощью `exec*p` на выполнение программу `prog`, соответствующим образом перенаправляя её стандартные потоки ввода-вывода.

Процесс `P1` генерирует `count` квадратов положительных целых чисел по модулю (то есть, остаток от деления) `modulo` и записывает их в канал. Например, последовательность первых 10 квадратов по модулю 10 равна `1 4 9 6 5 6 9 4 1 0`.

Процесс `P4` считывает данные, поступившие из своего канала и выводит их на стандартный поток вывода, заменяя символ пробела на символ `'\n'`.

Главный процесс ожитает окончания всей системы процессов, выводит на стандартный поток вывода число 0 и символ `'\n'` и завершает работу с кодом 0.

### com-18-18-01-3

Программе в аргументах командной строки передаются имена файлов для обработки. Файлы могут содержать произвольные данные. Главный процесс должен создать по процессу на каждый обрабатываемый файл. Каждый процесс должен найти байт, который встречается чаще всего. Если таких байтов несколько, то выбирается меньший байт. Для каждого файла в аргументаз командной строки процесс родитель должен вывести на стандартный поток вывода значение наиболее часто встречающегося байта и число его повторений. Если файл пуст, то выводится два нуля. Значения должны выводиться в том же порядке, в котором заданы имена файлов в командной строке.

Затем главный процесс получает от каждого процесса число повторений символа, который оказался наиболее частым в следующем по порядку файле. То есть, первый процесс сообщает родителю частоту повторений в первом файле того символа, который оказался наиболее частым по втором файле. Последний процесс берет наиболее частый символ первого файла. Если следующий по порядке файл оказался пустым, то процесс передает родителю значение 0. Главный процесс выводит на стандартный поток вывода полученные от сыновей числа в порядке следования файлов в командной строке.

Главный процесс дожидается окончания выполнения всех процессов и завершает работу с кодом 0. Для синхронизации и передачи файлов используйся семафоры и разделяемую память. Все объекты синхронизации должны быть уничтожены.

## 2018

### com02-1

Элемент двухсвязного списка описывается структурой `ListItem`:

```c
struct ListItem {
    struct ListItem *prev, *next;
    unsigned char *str;
}
```

```c
void process (struct ListItem *head, const unsigned char *prefix);
```

Напишите функцию `process`, которая принимает указатель на голову списка и строку для поиска. Функция просматривает элементы списка последовательно от начала к концу. Если у некоторого элемента  списка строка `str` начинается с префикса `prefix`, сразу после которого следует число `N`, записанное в десятичной системе без знаков `+` или `-`, имеющее значение от 1 до 255 (включительно), из списка должны быть удалены `N` элементов, непосредственно следующих за текущим обрабатываемым элементом, либо все оставшиеся элементы списка, если их меньше `N`. После этого функция переходит к просмотру элемента следующего за удалённым. Если строка `str` не удовлетворяет требованиям, описанным выше, то функция переходит к просмотру следующего элемента. Память, занимаемая удаленными элементами, должна быть корректно освобождена.

Например, если задана строка префикса `A`, а некоторый элемент списка хранит строку `A10`, то десять следующих после этого элемента элементов списка должны быть удалены.

Если элемент списка содержит строку `a2b`, то она считается не удовлетворяющей требованиям.

Программа, сдаваемая на процерку, должна содержать определение структуры `ListItem` и функцию `process`. Параметр `prefix` и поле `str` никогда не равны `NULL`.

### com02-2

Программе в аргументах командной строки передаются два имени программы `PROG1` и `PROG2` для запуска.
