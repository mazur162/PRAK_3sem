/*
Условный запуск программ

Программе в аргументах командной строки передаются три команды для выполнения. 
Программа должна запустить на выполнение процессы, чтобы они выполнялись 
в конфигурации, соответствующей команде shell:

{ cmd1 || cmd2 } && cmd3
Родительский процесс должен дождаться завершения всех созданных им процессов 
и сам завершить выполнение с кодом возврата 0 или 1 в зависимости от 
успешности выполнения процессов.

Команды cmd1, cmd2, cmd3 можно запускать на выполнение с помощью execlp.

Запись a || b означает то же самое, что !a?b:true. Запись a && b означает т
о же самое, что a?b:false. Скобки { и } используются для группировки.

Для шелла процесс считается завершившимся успешно, если процесс завершился 
с помощью системного вызова exit (макрос WIFEXITED возвращает истинное значение), 
и код завершения процесса (макрос WEXITSTATUS) равен 0. В других случаях 
процесс считается завершившимся неуспешно.

Соответственно, ваша программа должна завершиться с кодом 0 в случае 
успешного выполнения заданной группы процессов и с кодом 1 в случае 
неуспешного их выполнения.

Организуйте вашу программу таким образом, чтобы избежать дублирование кода. 
В частности, запуск процесса и проверка статуса его завершения может быть вынесена в функцию.

Примечания по тестированию вашей программы: . Тестирование завершается с
 вердиктом 'Synchronization error', если процесс-отец (то есть ваша программа, 
 запускаемая на тестирование) заканчивает работу раньше какого-либо из своих потомков.

*/

#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>


int 
main(int argc, char** argv) 
{
    int status;

    if (fork() == 0) 
    {
        if (fork() == 0) 
        {
            execlp(argv[1], argv[1], NULL);
            return 127;
        }
        wait(&status);
        
        if (WIFEXITED(status) && WEXITSTATUS(status) == 0) 
        {
            return 0;
        }
  
        if (fork() == 0) 
        {
            execlp(argv[2], argv[2], NULL);
            return 127;
        }
        wait(&status);
        
        if (WIFEXITED(status)) 
        {
            return WEXITSTATUS(status);
        }

        return WTERMSIG(status);
    }
    wait(&status);

    if ((WIFEXITED(status) && WEXITSTATUS(status) != 0) || WIFSIGNALED(status)) 
    {
        return 1;
    }
  
    if (fork() == 0) 
    {
        execlp(argv[3], argv[3], NULL);
        return 127;
    }
    wait(&status);

    if ((WIFEXITED(status) && WEXITSTATUS(status) != 0) || WIFSIGNALED(status)) 
    {
        return 1;
    }

    return 0;
}